<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GEARCALC PRO ‚Äî Involute Spur Gear Suite (Geometry + AGMA + ISO 6336 + Theory)</title>

  <!-- MathJax (LaTeX rendering) -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['\\[','\\]'], ['$$','$$']],
        processEscapes: true
      },
      options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <style>
    :root{
      --bg0:#070B14;
      --bg1:#0A1020;
      --text:#EAF0FF;
      --muted:#AEB8D6;
      --muted2:#8C97B8;
      --line:rgba(255,255,255,.10);

      --blue:#7AA2FF;
      --red:#FF6B6B;
      --green:#3DDC97;
      --purple:#B47CFF;

      --shadow: 0 18px 44px rgba(0,0,0,.45);
      --shadow2: 0 10px 28px rgba(0,0,0,.32);
      --r16:16px;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1300px 900px at 12% -10%, rgba(122,162,255,.22), transparent 60%),
        radial-gradient(900px 700px at 90% 0%, rgba(61,220,151,.10), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg0));
    }

    .shell{
      display:grid;
      grid-template-columns: 320px 1fr 320px;
      grid-template-rows: auto 1fr;
      gap:14px;
      padding:14px;
      min-height:100vh;
    }
    @media (max-width: 1180px){
      .shell{ grid-template-columns:1fr; grid-template-rows:auto auto auto auto; }
    }

    .topbar{ grid-column:1/-1; position:sticky; top:14px; z-index:50; }
    .sidebar{ grid-column:1; grid-row:2; }
    .main{ grid-column:2; grid-row:2; }
    .results{ grid-column:3; grid-row:2; }

    @media (max-width:1180px){
      .sidebar,.main,.results{ grid-column:1; grid-row:auto; }
      .topbar{ position:static; }
    }

    .sidebar,.results{
      position:sticky;
      top:92px;
      align-self:start;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-width:0;
    }
    @media (max-width:1180px){
      .sidebar,.results{ position:static; top:auto; }
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:var(--r16);
      box-shadow:var(--shadow);
      overflow:hidden;
      backdrop-filter: blur(6px);
    }
    .card .head{
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid var(--line);
      background: rgba(255,255,255,.02);
    }
    .card .head h2{
      margin:0;
      font-size:12px;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:var(--muted);
      font-weight:900;
    }
    .card .body{ padding:10px 12px; }

    .topbarInner{
      padding:10px 12px;
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .brandMini{ display:flex; flex-direction:column; gap:2px; min-width:240px; }
    .brandMini .kicker{
      font-size:11px; letter-spacing:.12em; text-transform:uppercase; color:var(--muted2);
      white-space:nowrap;
    }
    .brandMini .title{
      font-size:18px; font-weight:950; letter-spacing:.01em; line-height:1.1;
      white-space:nowrap;
    }

    .navTop{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:center;
      margin-left:auto;
    }
    .navbtn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      color:var(--text);
      padding:9px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:950;
      font-size:13px;
      transition:.15s ease;
      user-select:none;
      white-space:nowrap;
    }
    .navbtn:hover{
      transform:translateY(-1px);
      border-color:rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
      box-shadow:var(--shadow2);
    }
    .navbtn.active{
      background:rgba(122,162,255,.16);
      border-color:rgba(122,162,255,.40);
      box-shadow: inset 0 0 0 1px rgba(122,162,255,.18);
    }

    .topActions{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .field{ display:flex; flex-direction:column; gap:6px; min-width:0; }
    .field label{ font-size:12px; color:var(--muted); line-height:1.15; }
    .field input, .field select{
      width:100%;
      background:rgba(0,0,0,.22);
      color:var(--text);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:9px 10px;
      outline:none;
      font-size:13px;
    }
    .field input:focus, .field select:focus{
      border-color:rgba(122,162,255,.55);
      box-shadow: 0 0 0 3px rgba(122,162,255,.18);
    }

    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .sep{
      height:1px;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,.12), transparent);
      margin:10px 0;
    }

    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      font-size:13px;
      color:var(--muted);
      user-select:none;
    }
    .toggle input{ transform: translateY(1px); }

    .btn{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:var(--text);
      border-radius:14px;
      padding:9px 12px;
      font-weight:950;
      font-size:13px;
      cursor:pointer;
      transition:.15s transform ease, .15s background ease, .15s border-color ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{
      transform: translateY(-1px);
      background:rgba(255,255,255,.09);
      border-color:rgba(255,255,255,.18);
    }
    .btn.primary{
      background:rgba(122,162,255,.20);
      border-color:rgba(122,162,255,.46);
    }
    .btn.primary:hover{ background:rgba(122,162,255,.26); }
    .btn:disabled{ opacity:.45; cursor:not-allowed; transform:none !important; }

    .err{
      display:none;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,107,107,.45);
      background:rgba(255,107,107,.08);
      color:rgba(255,255,255,.92);
      font-size:13px;
      line-height:1.35;
    }

    .mono{ font-family:var(--mono); color:var(--text); }

    .main{ display:flex; flex-direction:column; gap:12px; min-width:0; }
    .page{ display:none; flex-direction:column; gap:12px; min-width:0; }
    .page.active{ display:flex; }

    .canvasWrap{ padding:10px 12px; display:flex; flex-direction:column; gap:8px; min-width:0; }
    canvas{
      width:100%;
      height:210px;
      background:linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,.12));
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      display:block;
    }
    .canvasMesh{ height:340px; }
    .canvasTall{ height:290px; }
    .canvasXL{ height:420px; }

    .split2{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width:1180px){ .split2{ grid-template-columns:1fr; } }

    .splitWide{ display:grid; grid-template-columns: 0.95fr 1.35fr; gap:12px; }
    @media (max-width:1180px){ .splitWide{ grid-template-columns:1fr; } }

    .stack{ display:flex; flex-direction:column; gap:12px; min-width:0; }

    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px 14px;
      font-size:13px;
      padding:10px 0;
      border-bottom:1px dashed rgba(255,255,255,.10);
    }
    .kv:last-child{ border-bottom:none; }
    .kv .k{ color:var(--muted); }
    .kv .v{ color:var(--text); font-family:var(--mono); font-weight:950; }

    .footer{
      color:rgba(255,255,255,.55);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      padding:0 2px 2px;
      margin-top:2px;
    }
    .footer .copy{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
      padding:10px 12px;
    }

    /* THEORY PAGE */
    .theory{
      padding:14px 16px;
      line-height:1.55;
      font-size:15px;
      color:rgba(255,255,255,.92);
    }
    .theory h1{
      margin:6px 0 10px;
      font-size:22px;
      letter-spacing:.01em;
    }
    .theory h2{
      margin:18px 0 8px;
      font-size:15px;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
    }
    .theory h3{
      margin:14px 0 6px;
      font-size:15px;
      color:rgba(255,255,255,.92);
    }
    .theory p{ margin:8px 0; color:rgba(255,255,255,.86); }
    .theory ul{ margin:8px 0 8px 20px; color:rgba(255,255,255,.86); }
    .theory li{ margin:6px 0; }
    .pill{
      display:inline-block;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.04);
      color:rgba(255,255,255,.88);
      font-weight:900;
      font-size:12px;
      letter-spacing:.02em;
      margin-right:8px;
      white-space:nowrap;
    }
    .note{
      border:1px solid rgba(122,162,255,.35);
      background: rgba(122,162,255,.08);
      padding:10px 12px;
      border-radius:14px;
      margin:10px 0;
      color: rgba(255,255,255,.90);
    }
    .warn{
      border:1px solid rgba(255,107,107,.35);
      background: rgba(255,107,107,.08);
      padding:10px 12px;
      border-radius:14px;
      margin:10px 0;
      color: rgba(255,255,255,.90);
    }
    .theory .eq{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      margin:10px 0;
      overflow:auto;
    }
    .theory code.inline{
      font-family: var(--mono);
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      padding:2px 6px;
      border-radius:10px;
      font-size:13px;
    }

    /* GENERATION LAB */
    .miniHelp{
      color:rgba(255,255,255,.70);
      font-size:12px;
      line-height:1.35;
    }

    /* ============================================================
       AUTH / LOGIN (client-side demo gate)
       ============================================================ */
    .loginRoot{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
      background:
        radial-gradient(1200px 850px at 18% -10%, rgba(122,162,255,.30), transparent 60%),
        radial-gradient(900px 700px at 92% 0%, rgba(61,220,151,.14), transparent 55%),
        linear-gradient(180deg, rgba(7,11,20,.98), rgba(10,16,32,.98) 55%, rgba(7,11,20,.98));
      z-index:9999;
    }
    .loginGrid{
      width:min(980px, 100%);
      display:grid;
      grid-template-columns: 1.25fr 0.85fr;
      gap:14px;
      align-items:stretch;
    }
    @media (max-width: 980px){
      .loginGrid{ grid-template-columns:1fr; }
    }
    .loginHero{
      padding:18px 18px 16px;
    }
    .loginHero h1{
      margin:6px 0 8px;
      font-size:26px;
      letter-spacing:.01em;
      line-height:1.1;
    }
    .loginHero .sub{
      color:rgba(255,255,255,.78);
      line-height:1.45;
      font-size:14px;
      margin:0 0 12px;
    }
    .loginBullets{
      margin:12px 0 0 18px;
      color:rgba(255,255,255,.82);
      line-height:1.45;
      font-size:14px;
    }
    .loginBullets li{ margin:8px 0; }
    .loginPanel{
      padding:16px 16px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .loginTitle{
      display:flex;
      flex-direction:column;
      gap:2px;
      margin-bottom:4px;
    }
    .loginTitle .kicker{
      font-size:11px; letter-spacing:.12em; text-transform:uppercase; color:var(--muted2);
    }
    .loginTitle .name{
      font-size:18px; font-weight:950; letter-spacing:.01em;
    }
    .loginRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:space-between;
    }
    .loginErr{
      display:none;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,107,107,.45);
      background:rgba(255,107,107,.08);
      color:rgba(255,255,255,.92);
      font-size:13px;
      line-height:1.35;
    }
    .userBadge{
      display:none;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.18);
      font-weight:950;
      font-size:13px;
      white-space:nowrap;
    }
    .userDot{
      width:10px; height:10px; border-radius:999px;
      background:rgba(61,220,151,.95);
      box-shadow: 0 0 0 3px rgba(61,220,151,.18);
    }

</style>
</head>

<body>

<div id="loginRoot" class="loginRoot" aria-label="GEARCALC PRO Login">
  <div class="loginGrid">
    <section class="card">
      <div class="head">
        <h2>GEARCALC PRO</h2>
        <span class="pill">NTUA</span>
      </div>
      <div class="loginHero">
        <div class="brandMini" style="min-width:0;">
          <div class="kicker">Machine Elements Laboratory ‚Äî School of Mechanical Engineering, NTUA</div>
          <div class="title" style="white-space:normal;">Involute Spur Gear Suite</div>
        </div>

        <h1>Geometry ‚Ä¢ Strength ‚Ä¢ Exports ‚Ä¢ Theory ‚Ä¢ Generation Lab</h1>
        <p class="sub">
          <b>GEARCALC PRO</b> is an educational/research tool for <b>involute spur gears</b>.
          It includes operating geometry (\(\alpha_w\), \(a_w\), \(\varepsilon_\alpha\)), key constraint checks,
          <b>AGMA</b> and <b>ISO 6336</b> strength calculations, <b>CSV</b> exports for FEA, and
          a visual rack‚Äëgeneration simulator for intuitive understanding.
        </p>

        <div class="note" style="margin-top:10px;">
          <span class="pill">Note</span>
          Login is <b>client‚Äëside</b> (a lightweight demo gate) intended for offline use/presentations. Real security requires a backend.
        </div>

        <h2 style="margin-top:14px;">What's inside</h2>
        <ul class="loginBullets">
          <li><b>Geometry:</b> base/addendum/root circles, profile shifts, tip thickness, undercut warnings.</li>
          <li><b>Strength:</b> bending & contact (AGMA) and root/contact checks (ISO 6336) with editable factors.</li>
          <li><b>Exports:</b> profile/tooth/full outline + FEA boundary segments.</li>
          <li><b>Theory:</b> full documentation of the formulas implemented in the tool (MathJax).</li>
          <li><b>Generation Lab:</b> visualization of rack‚Äëgeneration and involute trace in the local frame.</li>
        </ul>

        <div class="sep"></div>
        <div class="miniHelp">
          ¬© <span id="yearLogin"></span> Machine Elements Lab, NTUA ‚Äî Internal academic tool
        </div>
      </div>
    </section>

    <section class="card">
      <div class="head"><h2>Login</h2></div>
      <div class="loginPanel">
        <div class="loginTitle">
          <div class="kicker">Access required</div>
          <div class="name">Enter credentials</div>
        </div>

        <div class="field">
          <label>Username</label>
          <input id="loginUser" type="text" autocomplete="username" placeholder="Username">
        </div>
        <div class="field">
          <label>Password</label>
          <input id="loginPass" type="password" autocomplete="current-password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
        </div>

        <label class="toggle">
          <input type="checkbox" id="loginRemember" checked>
          Remember me on this device
        </label>

        <div class="loginRow">
          <button class="btn primary" id="loginBtn">Enter GEARCALC PRO</button>
          <button class="btn" id="loginClear">Clear</button>
        </div>

        <div class="loginErr" id="loginErr"></div>

        <div class="sep"></div>

        <div class="miniHelp">
          If you don‚Äôt have credentials, request them from the lab supervisors.
          <br>Goal: fast access for demos/presentations ‚Äî not a replacement for a real authentication system.
        </div>
      </div>
    </section>
  </div>
</div>

<div id="appRoot" style="display:none;">

<div class="shell">

  <header class="topbar card">
    <div class="topbarInner">
      <div class="brandMini">
        <div class="kicker">Machine Elements Laboratory ‚Äî NTUA</div>
        <div class="title">GEARCALC PRO</div>
      </div>

      <nav class="navTop" id="navPages">
        <button class="navbtn active" data-page="geometry">üß© Geometry</button>
        <button class="navbtn" data-page="strength">üõ°Ô∏è Strength (AGMA+ISO)</button>
        <button class="navbtn" data-page="export">üíæ Exports</button>
        <button class="navbtn" data-page="theory">üìò Theory</button>
        <button class="navbtn" data-page="generation">üõ†Ô∏è Generation Lab</button>
      </nav>

      <div class="topActions">
        <div class="userBadge" id="userBadge" title="Signed in">
          <span class="userDot"></span>
          <span id="userNameTxt">‚Äî</span>
        </div>
        <button class="btn" id="btnLogout" style="display:none;">Logout</button>
        <button class="btn primary" id="btnCompute">Compute All</button>
        <button class="btn" id="btnRedraw">Redraw</button>
      </div>
    </div>
  </header>

  <aside class="sidebar">
    <section class="card">
      <div class="head"><h2>Inputs</h2></div>
      <div class="body">
        <div class="grid">
          <div class="field">
            <label>Module m (mm)</label>
            <input id="m" type="number" step="0.01" value="3">
          </div>
          <div class="field">
            <label>Pressure angle Œ± (deg)</label>
            <input id="alpha" type="number" step="0.01" value="20">
          </div>

          <div class="field">
            <label>Pinion teeth z‚ÇÅ</label>
            <input id="z1" type="number" step="1" value="30">
          </div>
          <div class="field">
            <label>Gear teeth z‚ÇÇ</label>
            <input id="z2" type="number" step="1" value="31">
          </div>

          <div class="field">
            <label>Profile shift x‚ÇÅ (pinion)</label>
            <input id="x1" type="number" step="0.01" value="0.00">
          </div>
          <div class="field">
            <label>Profile shift x‚ÇÇ (gear)</label>
            <input id="x2" type="number" step="0.01" value="0.00">
          </div>

          <div class="field">
            <label>Addendum C<sub>k</sub></label>
            <input id="Ck" type="number" step="0.01" value="1.00">
          </div>
          <div class="field">
            <label>Dedendum C<sub>f</sub></label>
            <input id="Cf" type="number" step="0.01" value="1.25">
          </div>

          <div class="field">
            <label>Clearance C<sub>c</sub> (dimensionless)</label>
            <input id="Cc" type="number" step="0.01" value="0.25">
          </div>
          <div class="field">
            <label>Rack fillet target r<sub>c</sub> (mm)</label>
            <input id="rc" type="number" step="0.01" value="0.30">
          </div>

          <div class="field">
            <label>Face width b (mm)</label>
            <input id="b" type="number" step="0.1" value="20">
          </div>

          <div class="field">
            <label>Sampling N (CP)</label>
            <input id="N" type="number" step="50" value="1200">
          </div>

          <div class="field">
            <label>Speed n‚ÇÅ (rpm)</label>
            <input id="rpm" type="number" step="1" value="3000">
          </div>
          <div class="field">
            <label>Torque T‚ÇÅ (Nm)</label>
            <input id="torque" type="number" step="1" value="30">
          </div>
        </div>

        <div class="sep"></div>

        <div class="row">
          <label class="toggle"><input type="checkbox" id="showGear" /> Full outline</label>
          <label class="toggle"><input type="checkbox" id="showLOA" /> LOA (pinion)</label>
        </div>

        <div class="sep"></div>

        <div class="field">
          <label>Mesh zoom <span class="mono" id="zoomTxt">1.00√ó</span></label>
          <input id="zoom" type="range" min="0.60" max="12.00" step="0.05" value="1.00">
        </div>

        <div class="row" style="justify-content:flex-end;">
          <button class="btn" id="btnResetView">Reset view</button>
        </div>

        <div class="sep"></div>
        <div class="err" id="errBox"></div>
      </div>
    </section>
  </aside>

  <main class="main">

    <section class="page active" id="pageGeometry">
      <div class="split2">
        <section class="card">
          <div class="head"><h2>Pinion</h2></div>
          <div class="canvasWrap">
            <canvas id="cvPinion"></canvas>
          </div>
        </section>

        <section class="card">
          <div class="head"><h2>Gear</h2></div>
          <div class="canvasWrap">
            <canvas id="cvGear"></canvas>
          </div>
        </section>
      </div>

      <section class="card">
        <div class="head"><h2>Mesh preview</h2></div>
        <div class="canvasWrap">
          <canvas id="cvMesh" class="canvasMesh"></canvas>
        </div>
      </section>
    </section>

    <section class="page" id="pageStrength">
      <div class="splitWide">
        <div class="stack">

          <!-- AGMA inputs -->
          <section class="card">
            <div class="head">
              <h2>AGMA inputs</h2>
              <div class="row">
                <button class="btn" id="btnAGMAReset">Reset</button>
                <button class="btn primary" id="btnAGMARecalc">Recalculate</button>
              </div>
            </div>

            <div class="body">
              <div class="grid">
                <div class="field">
                  <label>Material preset</label>
                  <select id="agmaMat">
                    <option value="steel250">Steel (HB~250)</option>
                    <option value="steel300">Steel (HB~300)</option>
                    <option value="carb">Carburized & hardened</option>
                    <option value="nitr">Nitrided</option>
                    <option value="castiron">Cast iron (GG25)</option>
                    <option value="bronze">Bronze (Al bronze)</option>
                  </select>
                </div>
                <div class="field"><label>S<sub>t</sub> [MPa]</label><input id="agmaSt" type="number" step="1" value="430"></div>
                <div class="field"><label>S<sub>c</sub> [MPa]</label><input id="agmaSc" type="number" step="1" value="1100"></div>
                <div class="field"><label>E [MPa]</label><input id="agmaE" type="number" step="100" value="206000"></div>
                <div class="field"><label>Poisson's ratio ŒΩ [-]</label><input id="agmaNu" type="number" step="0.01" value="0.30"></div>
              </div>

              <div class="sep"></div>

              <div class="grid">
                <div class="field"><label>J‚ÇÅ (pinion)</label><input id="agmaJ1" type="number" step="0.001" value="0.300"></div>
                <div class="field"><label>J‚ÇÇ (gear)</label><input id="agmaJ2" type="number" step="0.001" value="0.300"></div>

                <label class="toggle" style="grid-column:1/-1;">
                  <input type="checkbox" id="agmaAutoJ" checked>
                  Auto J
                </label>

                <div class="field"><label>I (pitting)</label><input id="agmaI" type="number" step="0.001" value="0.100"></div>
                <div class="field"><label>Z<sub>R</sub></label><input id="agmaZR" type="number" step="0.01" value="1.00"></div>

                <label class="toggle" style="grid-column:1/-1;">
                  <input type="checkbox" id="agmaAutoI" checked>
                  Auto I
                </label>
              </div>

              <div class="sep"></div>

              <div class="grid">
                <div class="field"><label>K<sub>o</sub></label><input id="agmaKo" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>K<sub>v</sub></label><input id="agmaKv" type="number" step="0.01" value="1.10"></div>
                <div class="field"><label>K<sub>s</sub></label><input id="agmaKs" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>K<sub>H</sub></label><input id="agmaKH" type="number" step="0.01" value="1.30"></div>
                <div class="field"><label>K<sub>B</sub></label><input id="agmaKB" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>m<sub>N</sub></label><input id="agmaMN" type="number" step="0.01" value="1.00"></div>
              </div>

              <div class="sep"></div>

              <div class="grid">
                <div class="field"><label>Y<sub>N</sub></label><input id="agmaYN" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Z<sub>N</sub></label><input id="agmaZN" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Y<sub>T</sub></label><input id="agmaYT" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Y<sub>Z</sub></label><input id="agmaYZ" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Z<sub>W</sub></label><input id="agmaZW" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>S<sub>F</sub></label><input id="agmaSF" type="number" step="0.01" value="1.50"></div>
                <div class="field"><label>S<sub>H</sub></label><input id="agmaSH" type="number" step="0.01" value="1.50"></div>
              </div>

              <div class="sep"></div>
              <div class="err" id="agmaErr"></div>
            </div>
          </section>

          <!-- ISO inputs -->
          <section class="card">
            <div class="head">
              <h2>ISO 6336 inputs</h2>
              <div class="row">
                <button class="btn" id="btnISOReset">Reset</button>
                <button class="btn primary" id="btnISORecalc">Recalculate</button>
              </div>
            </div>

            <div class="body">
              <div class="grid">
                <div class="field">
                  <label>Material preset</label>
                  <select id="isoMat">
                    <option value="steel250">Steel (HB~250)</option>
                    <option value="steel300">Steel (HB~300)</option>
                    <option value="carb">Carburized & hardened</option>
                    <option value="nitr">Nitrided</option>
                    <option value="castiron">Cast iron (GG25)</option>
                    <option value="bronze">Bronze (Al bronze)</option>
                  </select>
                </div>

                <div class="field"><label>œÉ<sub>F,lim</sub> [MPa]</label><input id="isoFlim" type="number" step="1" value="430"></div>
                <div class="field"><label>œÉ<sub>H,lim</sub> [MPa]</label><input id="isoHlim" type="number" step="1" value="1100"></div>
                <div class="field"><label>E [MPa]</label><input id="isoE" type="number" step="100" value="206000"></div>
                <div class="field"><label>Poisson's ratio ŒΩ [-]</label><input id="isoNu" type="number" step="0.01" value="0.30"></div>
              </div>

              <div class="sep"></div>

              <div class="grid">
                <div class="field"><label>Y<sub>F1</sub> (pinion)</label><input id="isoYF1" type="number" step="0.01" value="2.20"></div>
                <div class="field"><label>Y<sub>F2</sub> (gear)</label><input id="isoYF2" type="number" step="0.01" value="2.20"></div>
                <div class="field"><label>Y<sub>S1</sub> (pinion)</label><input id="isoYS1" type="number" step="0.01" value="1.50"></div>
                <div class="field"><label>Y<sub>S2</sub> (gear)</label><input id="isoYS2" type="number" step="0.01" value="1.50"></div>

                <label class="toggle" style="grid-column:1/-1;">
                  <input type="checkbox" id="isoAutoY" checked>
                  Auto YF,YS (Lewis-based default)
                </label>
              </div>

              <div class="sep"></div>

              <div class="grid">
                <div class="field"><label>K<sub>A</sub></label><input id="isoKA" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>K<sub>v</sub></label><input id="isoKv" type="number" step="0.01" value="1.10"></div>

                <div class="field"><label>K<sub>HŒ≤</sub></label><input id="isoKHb" type="number" step="0.01" value="1.30"></div>
                <div class="field"><label>K<sub>HŒ±</sub></label><input id="isoKHa" type="number" step="0.01" value="1.00"></div>

                <div class="field"><label>K<sub>FŒ≤</sub></label><input id="isoKFb" type="number" step="0.01" value="1.30"></div>
                <div class="field"><label>K<sub>FŒ±</sub></label><input id="isoKFa" type="number" step="0.01" value="1.00"></div>
              </div>

              <div class="sep"></div>

              <div class="grid">
                <div class="field"><label>Z<sub>N</sub> (life)</label><input id="isoZN" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Z<sub>L</sub></label><input id="isoZL" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Z<sub>R</sub></label><input id="isoZR2" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Z<sub>V</sub></label><input id="isoZV" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Z<sub>W</sub></label><input id="isoZW2" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Z<sub>X</sub></label><input id="isoZX" type="number" step="0.01" value="1.00"></div>

                <div class="field"><label>Y<sub>ST</sub></label><input id="isoYST" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Y<sub>NT</sub></label><input id="isoYNT" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Y<sub>Œ¥relT</sub></label><input id="isoYdel" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Y<sub>RrelT</sub></label><input id="isoYR" type="number" step="0.01" value="1.00"></div>
                <div class="field"><label>Y<sub>X</sub></label><input id="isoYX" type="number" step="0.01" value="1.00"></div>

                <div class="field"><label>S<sub>F</sub></label><input id="isoSF" type="number" step="0.01" value="1.50"></div>
                <div class="field"><label>S<sub>H</sub></label><input id="isoSH" type="number" step="0.01" value="1.50"></div>

                <label class="toggle" style="grid-column:1/-1;">
                  <input type="checkbox" id="isoConservativeZeps" checked>
                  Conservative ZŒµ = 1 for ŒµŒ±&lt;2
                </label>
              </div>

              <div class="sep"></div>
              <div class="err" id="isoErr"></div>
            </div>
          </section>

        </div>

        <section class="card">
          <div class="head"><h2>Strength diagrams (AGMA vs ISO)</h2></div>
          <div class="canvasWrap">
            <canvas id="cvAGMAPinion" class="canvasTall"></canvas>
            <canvas id="cvAGMAGear" class="canvasTall"></canvas>

            <div class="sep"></div>

            <div class="kv"><div class="k">Pinion œÉF (AGMA / ISO) | allow (AGMA / ISO) [MPa]</div><div class="v" id="strength_sigF1">‚Äî</div></div>
            <div class="kv"><div class="k">Gear œÉF (AGMA / ISO) | allow (AGMA / ISO) [MPa]</div><div class="v" id="strength_sigF2">‚Äî</div></div>

            <div class="kv"><div class="k">Pinion œÉH (AGMA / ISO) | allow (AGMA / ISO) [MPa]</div><div class="v" id="strength_sigH1">‚Äî</div></div>
            <div class="kv"><div class="k">Gear œÉH (AGMA / ISO) | allow (AGMA / ISO) [MPa]</div><div class="v" id="strength_sigH2">‚Äî</div></div>

            <div class="kv"><div class="k">Safety factors</div><div class="v" id="strength_SFs">‚Äî</div></div>
          </div>
        </section>
      </div>
    </section>

    <section class="page" id="pageCSV">
      <div class="splitWide">

        <section class="card">
          <div class="head"><h2>Exports (pinion)</h2></div>
          <div class="body">
            <div class="row" style="margin-bottom:10px;">
              <button class="btn primary" id="btnCSV_Profile" disabled>Profile CSV</button>
              <button class="btn primary" id="btnCSV_Tooth" disabled>Tooth CSV</button>
              <button class="btn" id="btnCSV_Gear" disabled>Full outline CSV</button>
            </div>

            <div class="row" style="margin-bottom:10px;">
              <div class="field" style="min-width:260px; flex:1;">
                <label>FEA segment</label>
                <select id="segSelect" disabled>
                  <option value="rootL">01_rootCircle_L</option>
                  <option value="troL">02_trochoid_L</option>
                  <option value="invL">03_involute_L</option>
                  <option value="add">04_addendumArc</option>
                  <option value="invR">05_involute_R</option>
                  <option value="troR">06_trochoid_R</option>
                  <option value="rootR">07_rootCircle_R</option>
                </select>
              </div>
              <button class="btn" id="btnCSV_Segment" disabled>Segment CSV</button>
            </div>
          </div>
        </section>

        <section class="card">
          <div class="head"><h2>Data counts (pinion)</h2></div>
          <div class="body">
            <div id="segListInfo">
              <div class="kv"><div class="k">‚Äî</div><div class="v">‚Äî</div></div>
            </div>
          </div>
        </section>

      </div>

      <div class="splitWide">

        <section class="card">
          <div class="head"><h2>Exports (gear)</h2></div>
          <div class="body">
            <div class="row" style="margin-bottom:10px;">
              <button class="btn primary" id="btnCSV_Tooth2" disabled>Tooth CSV</button>
              <button class="btn" id="btnCSV_Gear2" disabled>Full outline CSV</button>
            </div>

            <div class="row" style="margin-bottom:10px;">
              <div class="field" style="min-width:260px; flex:1;">
                <label>FEA segment</label>
                <select id="segSelect2" disabled>
                  <option value="rootL">01_rootCircle_L</option>
                  <option value="troL">02_trochoid_L</option>
                  <option value="invL">03_involute_L</option>
                  <option value="add">04_addendumArc</option>
                  <option value="invR">05_involute_R</option>
                  <option value="troR">06_trochoid_R</option>
                  <option value="rootR">07_rootCircle_R</option>
                </select>
              </div>
              <button class="btn" id="btnCSV_Segment2" disabled>Segment CSV</button>
            </div>
          </div>
        </section>

        <section class="card">
          <div class="head"><h2>Data counts (gear)</h2></div>
          <div class="body">
            <div id="segListInfo2">
              <div class="kv"><div class="k">‚Äî</div><div class="v">‚Äî</div></div>
            </div>
          </div>
        </section>

      </div>
    </section>

    <!-- THEORY PAGE (reorganized + deeper rack‚ÜíLOA‚Üíprofiles narrative; math unchanged) -->
    <section class="page" id="pageTheory">
      <section class="card">
        <div class="head"><h2>Theory ‚Äî Geometry & Strength</h2></div>
        <div class="theory">
          <h1>Computation Theory (Involute spur gears)</h1>

          <div class="note">
            <span class="pill">Note</span>
            This page explains <b>exactly</b> the theory implemented in the tool. Equations are rendered in LaTeX via MathJax.
          </div>

          <h2>0) Computation flow & reference frames</h2>
          <p>
            The tool runs <b>two parallel tracks</b> in sync:
          </p>
          <ul>
            <li>
              <span class="pill">Operating geometry</span>
              From <span class="mono">x‚ÇÅ, x‚ÇÇ</span> it computes the <b>operating</b> \(\alpha_w\), \(a_w\), \(\varepsilon_\alpha\)
              and the line of action (LOA) at the operating center distance. These values are used for results and checks (contact, \(\varepsilon_\alpha\), etc.).
            </li>
            <li>
              <span class="pill">Rack generation (outline)</span>
              To produce a <b>physical tooth outline</b> (and the CSV FEA segments),
              it starts from the <b>rack (cutter)</b>, extracts the <b>contact path</b>, and maps it to pinion and gear profiles.
              The fillet (trochoid‚Äëlike) is introduced via <span class="mono">rack_fillet_v2</span> (target \(r_c\)).
            </li>
          </ul>

          <div class="note">
            <span class="pill">Frames</span>
            <ul>
              <li><b>Rack frame</b> \((x_r,y_r)\): the rack is straight. Typically \(y_r=0\) at the pitch line, \(y_r&lt;0\) towards the dedendum.</li>
              <li><b>Fixed gear frame</b> \((x,y)\): space‚Äëfixed, gear center at \((0,0)\), line of centers along \(y\).</li>
              <li><b>Pitch‚Äëpoint frame</b> \((x_{pp},y_{pp})\): same origin, but used to express the exported profile as produced by the mapping.</li>
            </ul>
          </div>

          <h2>1) Basic gear geometry</h2>
          <p>
            For a spur gear with module \(m\), tooth count \(z\), and nominal pressure angle \(\alpha\):
          </p>

          <div class="eq">
            \[
              d = mz,\qquad r=\frac{d}{2}=\frac{mz}{2}
            \]
            \[
              r_b = r\cos\alpha,\qquad d_b = d\cos\alpha
            \]
          </div>

          <p>
            With addendum/dedendum coefficients \(C_k, C_f\) and profile shift \(x\) (in module units):
          </p>
          <div class="eq">
            \[
              r_a = r + (C_k + x)m,\qquad
              r_f = r - (C_f - x)m
            \]
          </div>

          <h2>2) Involute function and operating pressure angle</h2>
          <p>
            Define the involute function:
          </p>
          <div class="eq">
            \[
              \operatorname{inv}(\phi)=\tan\phi-\phi
            \]
          </div>

          <p>
            For a pair \(z_1,z_2\) with total profile shift \(x_1+x_2\), the tool computes the operating pressure angle \(\alpha_w\) by solving:
          </p>
          <div class="eq">
            \[
              \operatorname{inv}(\alpha_w)
              =
              \operatorname{inv}(\alpha)
              +
              \frac{2(x_1+x_2)}{z_1+z_2}\tan\alpha
            \]
          </div>

          <p>
            (Solved numerically using Newton‚ÄìRaphson on the inverse involute.)
          </p>

          <h2>3) Operating center distance and working radii</h2>
          <p>
            The operating center distance follows from the constant base‚Äëpitch condition:
          </p>
          <div class="eq">
            \[
              a_w = \frac{m(z_1+z_2)}{2}\,\frac{\cos\alpha}{\cos\alpha_w}
            \]
          </div>

          <p>
            Working (operating) pitch radii:
          </p>
          <div class="eq">
            \[
              r_{w1}=\frac{r_{b1}}{\cos\alpha_w},\qquad
              r_{w2}=\frac{r_{b2}}{\cos\alpha_w}
            \]
          </div>

          <h2>4) Line of action length and transverse contact ratio</h2>
          <p>
            For spur gears, the LOA length is:
          </p>
          <div class="eq">
            \[
              L
              =
              \sqrt{r_{a1}^2-r_{b1}^2}
              +
              \sqrt{r_{a2}^2-r_{b2}^2}
              -
              a_w\sin\alpha_w
            \]
          </div>

          <p>
            Base pitch:
          </p>
          <div class="eq">
            \[
              p_b=\pi m\cos\alpha
            \]
          </div>

          <p>
            Transverse contact ratio:
          </p>
          <div class="eq">
            \[
              \varepsilon_\alpha=\frac{L}{p_b}
            \]
          </div>

          <h2>5) Rack ‚Üí contact path ‚Üí tooth profiles (as implemented)</h2>

          <h3>5.1) The rack as a generating tool</h3>
          <p>
            In the rack‚Äëgeneration approach, we use a straight rack with flank lines at pressure angle \(\alpha\).
            In the rack frame, sampling \(y_r\in[-C_f m,\, C_k m]\), the flank is modeled as:
          </p>
          <div class="eq">
            \[
              x_r(y_r)=-\tan\alpha\;y_r,\qquad
              \frac{dy_r}{dx_r}=-\frac{1}{\tan\alpha}
            \]
          </div>

          <p>
            The pair \((x_r,y_r)\) is the rack (tool) profile ‚Äî not the final gear profile.
            The gear profile is obtained via the rack‚Äëto‚Äëgear kinematic mapping.
          </p>

          <h3>5.2) Contact path (LOA) from the rack</h3>
          <p>
            For each rack point, the code computes a quantity \(K\) and derives the corresponding gear rotation:
          </p>
          <div class="eq">
            \[
              K = -\left(y_r\frac{dy_r}{dx_r}+x_r\right),\qquad
              \theta=\frac{K}{r_1}
            \]
          </div>

          <p>
            The corresponding contact point in the fixed gear frame is:
          </p>
          <div class="eq">
            \[
              x_{cp}=x_r+K,\qquad y_{cp}=y_r
            \]
          </div>

          <p>
            The tool then keeps the <b>active segment</b> where the contact point lies inside the addendum circles of <i>both</i> members (mask in the code):
          </p>
          <div class="eq">
            \[
              r_{A1}=\sqrt{x_{cp}^2+(y_{cp}+r_1)^2}\le r_{a1},\qquad
              r_{A2}=\sqrt{x_{cp}^2+(y_{cp}-r_2)^2}\le r_{a2}
            \]
          </div>

          <p>
            The largest continuous segment that satisfies these conditions is taken as the contact path used for profile generation.
          </p>

          <h3>5.3) Contact path ‚Üí pinion profile (pitch‚Äëpoint frame)</h3>
          <p>
            With pinion rotation \(\theta\), the contact point is mapped to a point on the pinion flank (as in the code):
          </p>
          <div class="eq">
            \[
              x_{pp}=x_{cp}\cos\theta-(y_{cp}+r_1)\sin\theta
            \]
            \[
              y_{pp}=x_{cp}\sin\theta+(y_{cp}+r_1)\cos\theta-r_1
            \]
          </div>

          <p>
            The set of \((x_{pp},y_{pp})\) along the contact path forms the involute flank (in the export frame used by the tool).
          </p>

          <h3>5.4) Mating gear profile generation</h3>
          <p>
            For gear 2 the tool applies an analogous mapping with radius \(r_2\) (implemented via <span class="mono">mapRackFlankToGear</span>):
            rack flank ‚Üí \(K,\theta\) ‚Üí point on the gear outline.
          </p>

          <div class="warn">
            <span class="pill">Important</span>
            The <i>operating</i> part (\(\alpha_w,a_w,\varepsilon_\alpha\)) is used for results and checks,
            while the <i>outline generation</i> part (rack mapping) is used for practical outlines (plots/exports/segments).
            The mathematics stays exactly as implemented ‚Äî this section simply documents the steps.
          </div>

          <h2>6) Checks (QC) shown in the UI</h2>
          <h3>6.1) Operating interference</h3>
          <p>
            Contact must occur above the base circles. For each LOA point \((x,y)\):
          </p>
          <div class="eq">
            \[
              r_1=\sqrt{x^2+y^2},\qquad
              r_2=\sqrt{x^2+(y-a_w)^2}
            \]
            \[
              \min(r_1)\ge r_{b1},\qquad \min(r_2)\ge r_{b2}
            \]
          </div>

          <h3>6.2) Manufacturing undercut (minimum teeth criterion)</h3>
          <p>
            The tool provides a warning using a simple rack‚Äëbased estimate:
          </p>
          <div class="eq">
            \[
              Z_{\min}\approx \frac{2\left[(C_f-x)-C_c(1-\sin\alpha)\right]}{\sin^2\alpha}
            \]
            and undercut risk if \(z &lt; Z_{\min}\).
          </div>

          <h3>6.3) Tip thickness</h3>
          <p>
            Tip thickness is computed from the angular span of the addendum arc. If \(\Delta\theta\) is the arc angle and \(r_a\) the addendum radius:
          </p>
          <div class="eq">
            \[
              s_a = r_a\,\Delta\theta
            \]
          </div>
          <p>
            A warning is shown if \(s_a &lt; 0.2m\), and an error if \(s_a\le 0\) (pointed tooth).
          </p>

          <h2>7) Loading from torque</h2>
          <p>
            The tangential force on the pinion from torque \(T_1\) is:
          </p>
          <div class="eq">
            \[
              F_t=\frac{T_1}{r_1}
              \quad\text{(with }r_1=\frac{mz_1}{2}\text{ in meters)}
            \]
          </div>

          <h2>8) AGMA (bending & contact) ‚Äî as implemented</h2>
          <p>
            <span class="pill">Bending</span>
            With factors \(K_o,K_v,K_s,K_H,K_B\) and geometry factor \(J\):
          </p>
          <div class="eq">
            \[
              \sigma_F =
              \frac{F_t\,K_oK_vK_sK_HK_B}{b\,m\,J}
            \]
          </div>

          <p>
            Allowable bending stress:
          </p>
          <div class="eq">
            \[
              \sigma_{F,\text{allow}}
              =
              \frac{S_t\,Y_N}{Y_T\,Y_Z\,S_F}
            \]
          </div>

          <p>
            <span class="pill">Contact</span>
            With AGMA contact geometry factor \(I\) and elastic coefficient \(Z_E\):
          </p>
          <div class="eq">
            \[
              \sigma_H
              =
              Z_E\sqrt{\frac{F_t\,K_oK_vK_sK_H\,Z_R}{b\,d_1\,I}}
            \]
          </div>

          <p>
            where \(d_1=mz_1\) and:
          </p>
          <div class="eq">
            \[
              Z_E=\sqrt{\frac{1}{\pi\left(\frac{2(1-\nu^2)}{E}\right)}}
            \]
          </div>

          <p>
            Allowable pitting/contact stress:
          </p>
          <div class="eq">
            \[
              \sigma_{H,\text{allow}}
              =
              \frac{S_c\,Z_NZ_W}{Y_T\,Y_Z\,S_H}
            \]
          </div>

          <div class="warn">
            <span class="pill">Important</span>
            The UI provides <b>Auto</b> approximations for \(J\) and \(I\) so the tool remains usable without AGMA charts.
            If you have accurate \(J,I\) values from AGMA charts, enter them manually and disable Auto.
          </div>

          <h2>9) ISO 6336 (spur) ‚Äî as implemented</h2>

          <h3>9.1) Base contact stress and modifiers</h3>
          <p>
            The ‚Äúbase‚Äù ISO‚Äëstyle contact stress in the code:
          </p>
          <div class="eq">
            \[
              \sigma_{H0}
              =
              Z_E\,Z_H\,Z_\varepsilon\,Z_\beta\,
              \sqrt{\frac{F_t(u+1)}{b\,d_1\,u}}
            \]
            where \(u=z_2/z_1\), and \(Z_\beta=1\) for spur gears.
          </div>

          <p>
            The \(Z_H\) term used (spur, \(\beta=0\)):
          </p>
          <div class="eq">
            \[
              Z_H=\sqrt{\frac{2\cos\alpha_w}{\cos^2\alpha\;\sin\alpha_w}}
            \]
          </div>

          <p>
            \(Z_\varepsilon\) is taken conservatively as \(1\) when \(\varepsilon_\alpha&lt;2\) (checkbox); otherwise:
          </p>
          <div class="eq">
            \[
              Z_\varepsilon=\sqrt{\frac{4-\varepsilon_\alpha}{3}}
            \]
          </div>

          <p>
            Load‚Äëdistribution/dynamic factors are applied as:
          </p>
          <div class="eq">
            \[
              K_H=\sqrt{K_AK_vK_{H\beta}K_{H\alpha}}
            \]
            \[
              \sigma_{H1}=Z_B\,\sigma_{H0}\,K_H,\qquad
              \sigma_{H2}=Z_D\,\sigma_{H0}\,K_H
            \]
          </div>

          <p>
            (\(Z_B,Z_D\) in the UI are computed using a simplified spur check so they remain \(\ge 1\).)
          </p>

          <p>
            Allowable contact stress:
          </p>
          <div class="eq">
            \[
              \sigma_{HP}
              =
              \frac{\sigma_{H,\text{lim}}\,Z_NZ_LZ_RZ_VZ_WZ_X}{S_H}
            \]
          </div>

          <h3>9.2) Root bending stress and allowable</h3>
          <p>
            The spur root bending stress used in the code:
          </p>
          <div class="eq">
            \[
              \sigma_{F0}=\frac{F_t}{b\,m}\,Y_FY_SY_\beta Y_BY_{DT}
            \]
            \[
              \sigma_F=\sigma_{F0}\,(K_AK_vK_{F\beta}K_{F\alpha})
            \]
          </div>
          <p>
            For spur gears: \(Y_\beta=Y_B=Y_{DT}=1\) (as implemented).
          </p>

          <p>
            Allowable bending stress:
          </p>
          <div class="eq">
            \[
              \sigma_{FP}
              =
              \frac{\sigma_{F,\text{lim}}\,Y_{ST}Y_{NT}Y_{\delta relT}Y_{R relT}Y_X}{S_F}
            \]
          </div>

          <div class="warn">
            <span class="pill">Important</span>
            \(Y_F\) and \(Y_S\) are provided with Auto (Lewis‚Äëbased) approximations so you don‚Äôt need ISO tables.
            If you want a more faithful ‚ÄúMethod B‚Äù, these factors can be computed from the generated root/fillet geometry.
          </div>

          <h2>10) What the program does (workflow)</h2>
          <ul>
            <li>Reads inputs \(m,\alpha,z_1,z_2,x_1,x_2,C_k,C_f\) and builds the main circles.</li>
            <li>Computes \(\alpha_w\) via the involute relation, then \(a_w\), \(L\), \(\varepsilon_\alpha\).</li>
            <li>Generates tooth outlines via rack‚Äëgeneration + fillet (target \(r_c\)).</li>
            <li>Computes tip thickness; checks pointed/low thickness, undercut, and interference.</li>
            <li>From \(T_1\) computes \(F_t\) and runs AGMA and ISO checks.</li>
            <li>Draws figures and enables CSV exports.</li>
          </ul>

          <div class="note">
            <span class="pill">Tip</span>
            If you want the notation to match your course/lab conventions 1:1, tell me the exact symbol set and I‚Äôll adapt the page accordingly.
          </div>
</div>
      </section>
    </section>

    <!-- NEW PAGE: GENERATION LAB -->
    <section class="page" id="pageGeneration">
      <div class="split2">

        <section class="card">
          <div class="head">
            <h2>Simulation ‚Äî Rack cutting kinematics (rack‚Äëgeneration)</h2>
            <div class="row">
              <button class="btn primary" id="cutPlay">Play</button>
              <button class="btn" id="cutReset">Reset</button>
            </div>
          </div>
          <div class="canvasWrap">
            <canvas id="cvCutRack" class="canvasXL"></canvas>

            <div class="sep"></div>

            <div class="grid" style="align-items:end;">
              <div class="field" style="grid-column:1/-1;">
                <label>Phase <span class="mono" id="cutTtxt">0.00</span></label>
                <input id="cutT" type="range" min="0" max="1" step="0.001" value="0">
              </div>

              <div class="field">
                <label>Speed <span class="mono" id="cutSpTxt">1.00√ó</span></label>
                <input id="cutSpeed" type="range" min="0.25" max="3.50" step="0.05" value="1.00">
              </div>

              <div class="field">
                <label>View</label>
                <select id="cutView">
                  <option value="pinion" selected>Pinion generation</option>
                  <option value="gear">Gear generation</option>
                </select>
              </div>

              <div class="field" style="grid-column:1/-1;">
                <label>Simulation zoom <span class="mono" id="cutZoomTxt">1.00√ó</span></label>
                <input id="cutZoom" type="range" min="0.60" max="12.00" step="0.05" value="1.00">
              </div>

              <div class="row" style="justify-content:flex-end; grid-column:1/-1;">
                <button class="btn" id="cutResetView">Reset view</button>
              </div>

              <label class="toggle" style="grid-column:1/-1;">
                <input type="checkbox" id="cutShowLOA" checked>
                Show LOA (operating)
              </label>
              <label class="toggle" style="grid-column:1/-1;">
                <input type="checkbox" id="cutShowRack" checked>
                Show rack cutter (stylized)
              </label>
            </div>

            <div class="sep"></div>
            <div class="miniHelp">
              ‚Ä¢ This is a <b>visual ‚Äúgeneration‚Äù simulator</b>: the rack translates, the gear rotates, and the contact point moves along the LOA. <br>
              ‚Ä¢ It uses the <b>same</b> operating-geometry results (\(\alpha_w\), LOA, involute segment) to keep the motion consistent. It does not change the underlying methodology/mathematics.
            </div>
          </div>
        </section>

        <section class="card">
          <div class="head"><h2>Simulation ‚Äî Involute trace (local frame)</h2></div>
          <div class="canvasWrap">
            <canvas id="cvCutTrace" class="canvasXL"></canvas>

            <div class="sep"></div>

            <div class="grid">
              <label class="toggle" style="grid-column:1/-1;">
                <input type="checkbox" id="cutShowTrace" checked>
                Show accumulated trace (generated flank)
              </label>
              <label class="toggle" style="grid-column:1/-1;">
                <input type="checkbox" id="cutShowTarget" checked>
                Show target involute (from your generated outline)
              </label>
            </div>

            <div class="sep"></div>

            <div class="note">
              <span class="pill">Idea (innovative)</span>
              On the right you see the ‚Äútrace‚Äù left by the contact point when it is mapped back to the gear body (local frame).
              This is a clean way to <b>see</b> how the rack ‚Äúgenerates‚Äù the involute.
            </div>
          </div>
        </section>

      </div>
    </section>

    <div class="footer">
      <div class="copy">¬© <span id="year"></span> Machine Design Lab, NTUA ‚Äî GEARCALC PRO</div>
      <div class="copy">Geometry ‚Ä¢ Strength (AGMA+ISO) ‚Ä¢ Exports ‚Ä¢ Theory ‚Ä¢ Generation Lab</div>
    </div>

  </main>

  <aside class="results">
    <section class="card">
      <div class="head"><h2>Key results</h2></div>
      <div class="body">

        <div class="kv"><div class="k">Operating pressure angle Œ±<sub>w</sub> [deg]</div><div class="v" id="res_aw">‚Äî</div></div>
        <div class="kv"><div class="k">Center distance a<sub>12</sub> [mm]</div><div class="v" id="res_a12">‚Äî</div></div>

        <div class="sep"></div>

        <div class="kv"><div class="k">Contact ratio Œµ<sub>Œ±</sub></div><div class="v" id="res_eps">‚Äî</div></div>
        <div class="kv"><div class="k">Contact path L<sub>LOA</sub> [mm]</div><div class="v" id="res_loa">‚Äî</div></div>

        <div class="sep"></div>

        <div class="kv"><div class="k">d‚ÇÄ (pinion / gear) [mm]</div><div class="v" id="res_d0">‚Äî</div></div>
        <div class="kv"><div class="k">d<sub>g</sub> base (pinion / gear) [mm]</div><div class="v" id="res_dg">‚Äî</div></div>
        <div class="kv"><div class="k">d<sub>b</sub> working (pinion / gear) [mm]</div><div class="v" id="res_db">‚Äî</div></div>
        <div class="kv"><div class="k">d<sub>k</sub> tip (pinion / gear) [mm]</div><div class="v" id="res_dk">‚Äî</div></div>
        <div class="kv"><div class="k">d<sub>f</sub> root (pinion / gear) [mm]</div><div class="v" id="res_df">‚Äî</div></div>

        <div class="sep"></div>

        <div class="kv"><div class="k">Tip thickness s<sub>a1</sub> (pinion) [mm]</div><div class="v" id="res_tip1">‚Äî</div></div>
        <div class="kv"><div class="k">Tip thickness s<sub>a2</sub> (gear) [mm]</div><div class="v" id="res_tip2">‚Äî</div></div>

        <div class="kv"><div class="k">Operating interference</div><div class="v" id="res_interf">‚Äî</div></div>
        <div class="kv"><div class="k">Undercut (rack-gen)</div><div class="v" id="res_uc">‚Äî</div></div>

        <div class="sep"></div>

        <div class="kv"><div class="k">AGMA result</div><div class="v" id="res_agma">‚Äî</div></div>
        <div class="kv"><div class="k">ISO result</div><div class="v" id="res_iso">‚Äî</div></div>

        <div class="sep"></div>
        <div class="err" id="warnBox"></div>
      </div>
    </section>
  </aside>

</div>
</div>

<script>
(function(){
  "use strict";

  const el = (id) => document.getElementById(id);

  // ============================================================
  // AUTH / LOGIN (client-side demo gate)
  // ============================================================
  // NOTE: This is NOT secure authentication. It is a lightweight gate for
  // offline demos / lab presentations. For real access control use a backend.
  const AUTH_PROFILES = {
    ckal:   { pass: "CKAL-2026",   label: "ckal"    },
    jsav:   { pass: "JSAV-2026",   label: "jsav"    },
    vspitas:{ pass: "VSPITAS-2026",label: "vspitas" },
    noname: { pass: "NONAME-2026", label: "noname"  }
  };

  const AUTH_KEY = "GEARCALC_PRO_AUTH_USER_V1";

  const auth = {
    loginRoot: el("loginRoot"),
    appRoot: el("appRoot"),
    user: el("loginUser"),
    pass: el("loginPass"),
    btn: el("loginBtn"),
    clear: el("loginClear"),
    err: el("loginErr"),
    remember: el("loginRemember"),
    badge: el("userBadge"),
    badgeTxt: el("userNameTxt"),
    logout: el("btnLogout"),
    yearLogin: el("yearLogin")
  };

  function authSetErr(msg){
    if(!auth.err) return;
    if(!msg){
      auth.err.style.display = "none";
      auth.err.textContent = "";
      return;
    }
    auth.err.style.display = "block";
    auth.err.textContent = msg;
  }

  function authGetStoredUser(){
    const u1 = sessionStorage.getItem(AUTH_KEY);
    if(u1) return u1;
    const u2 = localStorage.getItem(AUTH_KEY);
    return u2 || "";
  }

  function authStoreUser(u, remember){
    try{
      sessionStorage.removeItem(AUTH_KEY);
      localStorage.removeItem(AUTH_KEY);
      if(remember) localStorage.setItem(AUTH_KEY, u);
      else sessionStorage.setItem(AUTH_KEY, u);
    }catch(e){}
  }

  function authShowApp(u){
    if(auth.loginRoot) auth.loginRoot.style.display = "none";
    if(auth.appRoot) auth.appRoot.style.display = "block";

    if(auth.badge){
      auth.badge.style.display = "inline-flex";
      auth.badgeTxt.textContent = u;
    }
    if(auth.logout) auth.logout.style.display = "inline-flex";

    authSetErr("");
  }

  function authShowLogin(msg){
    if(auth.loginRoot) auth.loginRoot.style.display = "flex";
    if(auth.appRoot) auth.appRoot.style.display = "none";
    if(auth.badge) auth.badge.style.display = "none";
    if(auth.logout) auth.logout.style.display = "none";
    authSetErr(msg || "");
    if(auth.user) auth.user.focus();
  }

  function authDoLogin(){
    const u = (auth.user?.value || "").trim();
    const p = (auth.pass?.value || "");

    if(!u || !p){
      authShowLogin("Please enter both username and password.");
      return;
    }
    if(!AUTH_PROFILES[u] || AUTH_PROFILES[u].pass !== p){
      authShowLogin("Invalid credentials. Please try again.");
      return;
    }
    authStoreUser(u, !!auth.remember?.checked);
    authShowApp(u);
  }

  function authDoLogout(){
    try{
      sessionStorage.removeItem(AUTH_KEY);
      localStorage.removeItem(AUTH_KEY);
    }catch(e){}
    // Soft reset (keeps page consistent with existing initialization)
    location.reload();
  }

  // Wire login events early
  if(auth.btn) auth.btn.addEventListener("click", authDoLogin);
  if(auth.clear) auth.clear.addEventListener("click", ()=>{
    if(auth.user) auth.user.value = "";
    if(auth.pass) auth.pass.value = "";
    authSetErr("");
    auth.user?.focus();
  });

  if(auth.pass) auth.pass.addEventListener("keydown", (ev)=>{
    if(ev.key === "Enter") authDoLogin();
  });
  if(auth.user) auth.user.addEventListener("keydown", (ev)=>{
    if(ev.key === "Enter") authDoLogin();
  });

  if(auth.logout) auth.logout.addEventListener("click", authDoLogout);

  // If already signed in, go straight to app
  const _u = authGetStoredUser();
  if(_u && AUTH_PROFILES[_u]) authShowApp(_u);
  else authShowLogin("");

  const ui = {
    m: el("m"), alpha: el("alpha"), z1: el("z1"), z2: el("z2"),
    x1: el("x1"), x2: el("x2"),
    Ck: el("Ck"), Cf: el("Cf"), Cc: el("Cc"),
    b: el("b"), rc: el("rc"), N: el("N"),
    rpm: el("rpm"), torque: el("torque"),
    showGear: el("showGear"), showLOA: el("showLOA"),
    zoom: el("zoom"), zoomTxt: el("zoomTxt"), btnResetView: el("btnResetView"),
    btnCompute: el("btnCompute"), btnRedraw: el("btnRedraw"),
    navPages: el("navPages"),
    errBox: el("errBox"),
    warnBox: el("warnBox"),
    agmaErr: el("agmaErr"),
    isoErr: el("isoErr"),
    pages: {
      geometry: el("pageGeometry"),
      strength: el("pageStrength"),
      export: el("pageCSV"),
      theory: el("pageTheory"),
      generation: el("pageGeneration")
    },

    cvMesh: el("cvMesh"),
    cvPinion: el("cvPinion"),
    cvGear: el("cvGear"),
    cvAGMAPinion: el("cvAGMAPinion"),
    cvAGMAGear: el("cvAGMAGear"),

    // Generation Lab
    cvCutRack: el("cvCutRack"),
    cvCutTrace: el("cvCutTrace"),
    cutPlay: el("cutPlay"),
    cutReset: el("cutReset"),
    cutT: el("cutT"),
    cutTtxt: el("cutTtxt"),
    cutSpeed: el("cutSpeed"),
    cutSpTxt: el("cutSpTxt"),
    cutView: el("cutView"),
    cutZoom: el("cutZoom"),
    cutZoomTxt: el("cutZoomTxt"),
    cutResetView: el("cutResetView"),
    cutShowLOA: el("cutShowLOA"),
    cutShowRack: el("cutShowRack"),
    cutShowTrace: el("cutShowTrace"),
    cutShowTarget: el("cutShowTarget"),

    // key results
    res_aw: el("res_aw"),
    res_a12: el("res_a12"),
    res_eps: el("res_eps"),
    res_loa: el("res_loa"),
    res_d0: el("res_d0"),
    res_dg: el("res_dg"),
    res_db: el("res_db"),
    res_dk: el("res_dk"),
    res_df: el("res_df"),
    res_tip1: el("res_tip1"),
    res_tip2: el("res_tip2"),
    res_interf: el("res_interf"),
    res_uc: el("res_uc"),
    res_agma: el("res_agma"),
    res_iso: el("res_iso"),

    btnCSV_Profile: el("btnCSV_Profile"),
    btnCSV_Tooth: el("btnCSV_Tooth"),
    btnCSV_Gear: el("btnCSV_Gear"),
    btnCSV_Segment: el("btnCSV_Segment"),
    segSelect: el("segSelect"),
    segListInfo: el("segListInfo"),

    btnCSV_Tooth2: el("btnCSV_Tooth2"),
    btnCSV_Gear2: el("btnCSV_Gear2"),
    btnCSV_Segment2: el("btnCSV_Segment2"),
    segSelect2: el("segSelect2"),
    segListInfo2: el("segListInfo2"),

    // AGMA
    agmaMat: el("agmaMat"),
    agmaSt: el("agmaSt"),
    agmaSc: el("agmaSc"),
    agmaE: el("agmaE"),
    agmaNu: el("agmaNu"),
    agmaJ1: el("agmaJ1"),
    agmaJ2: el("agmaJ2"),
    agmaAutoJ: el("agmaAutoJ"),
    agmaI: el("agmaI"),
    agmaAutoI: el("agmaAutoI"),
    agmaZR: el("agmaZR"),
    agmaKo: el("agmaKo"),
    agmaKv: el("agmaKv"),
    agmaKs: el("agmaKs"),
    agmaKH: el("agmaKH"),
    agmaKB: el("agmaKB"),
    agmaMN: el("agmaMN"),
    agmaYN: el("agmaYN"),
    agmaZN: el("agmaZN"),
    agmaYT: el("agmaYT"),
    agmaYZ: el("agmaYZ"),
    agmaZW: el("agmaZW"),
    agmaSF: el("agmaSF"),
    agmaSH: el("agmaSH"),
    btnAGMAReset: el("btnAGMAReset"),
    btnAGMARecalc: el("btnAGMARecalc"),

    // ISO
    isoMat: el("isoMat"),
    isoFlim: el("isoFlim"),
    isoHlim: el("isoHlim"),
    isoE: el("isoE"),
    isoNu: el("isoNu"),
    isoYF1: el("isoYF1"),
    isoYF2: el("isoYF2"),
    isoYS1: el("isoYS1"),
    isoYS2: el("isoYS2"),
    isoAutoY: el("isoAutoY"),
    isoKA: el("isoKA"),
    isoKv: el("isoKv"),
    isoKHb: el("isoKHb"),
    isoKHa: el("isoKHa"),
    isoKFb: el("isoKFb"),
    isoKFa: el("isoKFa"),
    isoZN: el("isoZN"),
    isoZL: el("isoZL"),
    isoZR2: el("isoZR2"),
    isoZV: el("isoZV"),
    isoZW2: el("isoZW2"),
    isoZX: el("isoZX"),
    isoYST: el("isoYST"),
    isoYNT: el("isoYNT"),
    isoYdel: el("isoYdel"),
    isoYR: el("isoYR"),
    isoYX: el("isoYX"),
    isoSF: el("isoSF"),
    isoSH: el("isoSH"),
    isoConservativeZeps: el("isoConservativeZeps"),
    btnISOReset: el("btnISOReset"),
    btnISORecalc: el("btnISORecalc"),

    // strength outputs
    strength_sigF1: el("strength_sigF1"),
    strength_sigF2: el("strength_sigF2"),
    strength_sigH1: el("strength_sigH1"),
    strength_sigH2: el("strength_sigH2"),
    strength_SFs: el("strength_SFs")
  };

  el("year").textContent = new Date().getFullYear();
  const yL = el("yearLogin"); if(yL) yL.textContent = new Date().getFullYear();
  ui.showGear.checked = false;
  ui.showLOA.checked = false;

  const state = {
    activePage: "geometry",
    base: null,
    oper: null,
    qc: null,
    lastProfilePP: null,

    pinionTooth: null,
    pinionFull: null,
    pinionSeg: null,

    gearTooth: null,
    gearFull: null,
    gearSeg: null,

    agma: null,
    iso: null,

    view: { zoom: 1.0, panX: 0, panY: 0 },
    drag: { on:false, x0:0, y0:0, panX0:0, panY0:0 },

    genView: { zoom: 1.0, panX: 0, panY: 0, _rack:null, _trace:null },
    genDrag: { on:false, x0:0, y0:0, panX0:0, panY0:0, target:"rack" },

    gen: { running:false, t:0, speed:1, lastTs:0, trace:[], trace2:[] }
  };

  // ----------------------
  // Utilities
  // ----------------------
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function deg2rad(d){ return d*Math.PI/180; }
  function rad2deg(r){ return r*180/Math.PI; }
  function fmt(v, nd=6){
    if (!isFinite(v)) return "‚Äî";
    const s = Number(v).toFixed(nd);
    return s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
  }
  function fmtPair(a,b, nd=2){
    if (!isFinite(a) || !isFinite(b)) return "‚Äî";
    return fmt(a,nd) + " / " + fmt(b,nd);
  }
  function showErr(box, msg){
    if (!box) return;
    if (!msg){ box.style.display="none"; box.textContent=""; return; }
    box.style.display="block";
    box.innerHTML = msg;
  }
  function setVal(node, txt, color){
    if (!node) return;
    node.textContent = txt;
    node.style.color = color || "";
  }
  function linspace(a,b,n){
    if (n<=1) return [a];
    const arr = new Array(n);
    const step = (b-a)/(n-1);
    for (let i=0;i<n;i++) arr[i] = a + step*i;
    return arr;
  }
  function rotateXY(x, y, ang){
    const c = Math.cos(ang), s = Math.sin(ang);
    return [x*c - y*s, x*s + y*c];
  }
  function downloadCSV(filename, rows){
    const csv = rows.map(r => r.join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function setupHiDPICanvas(cv){
    const ctx = cv.getContext("2d");
    const dpr = window.devicePixelRatio || 1;
    const cssW = cv.clientWidth || 600;
    const cssH = cv.clientHeight || 300;
    cv.width  = Math.round(cssW*dpr);
    cv.height = Math.round(cssH*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,cssW,cssH);
    return {ctx, cssW, cssH};
  }
  function arcXY(r, th1, th2, N, includeEnds){
    const pts = [];
    if (N < 2) N = 2;
    let th = includeEnds ? linspace(th1, th2, N) : linspace(th1, th2, N+2).slice(1,-1);
    for (let i=0;i<th.length;i++){
      const t = th[i];
      pts.push([r*Math.sin(t), r*Math.cos(t)]);
    }
    return pts;
  }

  // ----------------------
  // Involute + inverse involute
  // ----------------------
  function invAngle(a){ return Math.tan(a) - a; }

  function invToAngle(invphi){
    if (!(invphi >= 0)) throw new Error("Invalid inv(): invphi < 0.");
    if (invphi > Math.PI) throw new Error("Invalid inv(): invphi > œÄ.");
    if (invphi === 0) return 0;

    let phi;
    if (invphi < 0.5){
      phi = 1.441*Math.cbrt(invphi) - 0.366*invphi;
    } else {
      phi = 0.243*Math.PI - 0.471*Math.atan(invphi);
    }

    const itMax = 60;
    const tol = 1e-13;
    for (let k=0;k<itMax;k++){
      const t = Math.tan(phi);
      const f = (t - phi) - invphi;
      const fp = t*t;
      const dphi = -f / Math.max(1e-15, fp);
      phi = phi + dphi;
      if (Math.abs(dphi) <= tol) break;
    }
    return phi;
  }

  // (continued)
  // ----------------------
  // Operating geometry from profile shifts
  // ----------------------
  function computeOperatingFromShifts({m,z1,z2,alpha0,Ck,Cf,x1,x2,Nlo=400}){
    const ro1 = m*z1/2, ro2 = m*z2/2;
    const rb1 = ro1*Math.cos(alpha0), rb2 = ro2*Math.cos(alpha0);

    const ra1 = ro1 + (Ck + x1)*m;
    const ra2 = ro2 + (Ck + x2)*m;
    const rf1 = ro1 - (Cf - x1)*m;
    const rf2 = ro2 - (Cf - x2)*m;

    if (!(Ck + x1 > 0 && Ck + x2 > 0)) throw new Error("Invalid: (Ck + x) must be > 0 for both gears.");
    if (!(Cf - x1 > 0 && Cf - x2 > 0)) throw new Error("Invalid: (Cf - x) must be > 0 for both gears.");

    const inva0 = invAngle(alpha0);
    const invaw = inva0 + (2*(x1 + x2)/(z1 + z2))*Math.tan(alpha0);
    const alphaW = invToAngle(invaw);

    const a12 = ((z1 + z2)*m/2) * (Math.cos(alpha0)/Math.cos(alphaW));

    const rg1 = ro1*Math.cos(alpha0);
    const rg2 = ro2*Math.cos(alpha0);
    const rw1 = rg1/Math.cos(alphaW);
    const rw2 = rg2/Math.cos(alphaW);
    const db1 = 2*rw1;
    const db2 = 2*rw2;

    const d01 = m*z1, d02 = m*z2;
    const dg1 = d01*Math.cos(alpha0);
    const dg2 = d02*Math.cos(alpha0);
    const dk1 = 2*ra1, dk2 = 2*ra2;
    const df1 = 2*rf1, df2 = 2*rf2;

    const term1 = ra1*ra1 - rb1*rb1;
    const term2 = ra2*ra2 - rb2*rb2;
    if (term1 <= 0 || term2 <= 0){
      throw new Error("Invalid: ra <= rb for one gear (no involute contact).");
    }
    const L = Math.sqrt(term1) + Math.sqrt(term2) - a12*Math.sin(alphaW);
    if (!(L > 0)) throw new Error("Invalid LOA length (<=0).");

    const pb = Math.PI*m*Math.cos(alpha0);
    const eps = L / pb;

    const sA = Math.sqrt(term2) - rw2*Math.sin(alphaW);
    const sR = Math.sqrt(term1) - rw1*Math.sin(alphaW);
    const nPts = Math.max(50, Math.round(Nlo));
    const sArr = linspace(-sA, sR, nPts);
    const xLOA = new Array(nPts);
    const yLOA = new Array(nPts);
    const c = Math.cos(alphaW), s = Math.sin(alphaW);
    for (let i=0;i<nPts;i++){
      const ss = sArr[i];
      xLOA[i] = ss*c;
      yLOA[i] = rw1 + ss*s;
    }

    return {
      ro1,ro2, rb1,rb2, ra1,ra2, rf1,rf2,
      inva0, invaw, alphaW, a12,
      rg1,rg2, rw1,rw2,
      d01,d02, dg1,dg2, db1,db2, dk1,dk2, df1,df2,
      pb, L, eps,
      xLOA, yLOA
    };
  }

  // ----------------------
  // QC helpers
  // ----------------------
  function tipThicknessSignedFromAddArc(segAdd){
    if (!segAdd || segAdd.length < 2) return { sa: NaN, dtheta: NaN, rA: NaN };
    const pL = segAdd[0];
    const pR = segAdd[segAdd.length - 1];
    const rA = 0.5*(Math.hypot(pL[0], pL[1]) + Math.hypot(pR[0], pR[1]));
    const thL = Math.atan2(pL[0], pL[1]);
    const thR = Math.atan2(pR[0], pR[1]);
    let d = Math.atan2(Math.sin(thR - thL), Math.cos(thR - thL));
    const sa = rA * d;
    return { sa, dtheta: d, rA };
  }

  function checkOperatingInterferenceOperating(oper){
    const tol = 1e-6 * Math.max(oper.ro1, oper.ro2);
    let minR1 = +Infinity, minR2 = +Infinity;
    for (let i=0;i<oper.xLOA.length;i++){
      const x = oper.xLOA[i], y = oper.yLOA[i];
      const r1 = Math.hypot(x, y);
      const r2 = Math.hypot(x, y - oper.a12);
      if (r1 < minR1) minR1 = r1;
      if (r2 < minR2) minR2 = r2;
    }
    const margin1 = minR1 - oper.rb1;
    const margin2 = minR2 - oper.rb2;
    return {
      minR1, minR2,
      margin1, margin2,
      pinionInterference: (margin1 < -tol),
      gearInterference:   (margin2 < -tol)
    };
  }

  function checkManufacturingUndercut(z, alphaRad, Cf, Cc, x){
    const sinA = Math.sin(alphaRad);
    const denom = sinA*sinA;
    if (!(denom > 1e-15)) return { Zmin: Infinity, Cc, x, hasUndercut: true };

    const Cf_eff = Cf - x;
    const Zmin = 2 * (Cf_eff - Cc*(1 - sinA)) / denom;
    const hasUndercut = z < (Zmin - 1e-9);
    return { Zmin, Cc, x, hasUndercut };
  }

  // ----------------------
  // Legacy rack-based LOA/profile used for outlines
  // ----------------------
  function computeInvoluteLOAandProfile({ m, z1, z2, alphaRad, Ck, Cf, x1, x2, N }){
    if (!(m>0)) throw new Error("Module m must be > 0.");
    if (!(z1>=3 && Number.isInteger(z1))) throw new Error("z1 must be integer ‚â• 3.");
    if (!(z2>=3 && Number.isInteger(z2))) throw new Error("z2 must be integer ‚â• 3.");
    if (!(alphaRad>0 && alphaRad<Math.PI/2)) throw new Error("Pressure angle must be in (0, 90¬∞).");
    if (!(Ck>0 && Cf>0)) throw new Error("Ck and Cf must be > 0.");
    if (!(N>=200 && Number.isFinite(N))) throw new Error("Sampling points N must be ‚â• 200.");

    const ro1 = z1*m/2;
    const ro2 = z2*m/2;
    const rb1 = ro1*Math.cos(alphaRad);
    const rb2 = ro2*Math.cos(alphaRad);

    const ra1 = ro1 + (Ck + x1)*m;
    const ra2 = ro2 + (Ck + x2)*m;
    const rf1 = ro1 - (Cf - x1)*m;
    const rf2 = ro2 - (Cf - x2)*m;

    const yr = linspace(-Cf*m, Ck*m, N);
    const xr = yr.map(v => -Math.tan(alphaRad)*v);
    const dydx = yr.map(() => -1/Math.tan(alphaRad));

    const K = yr.map((y,i) => -(y*dydx[i] + xr[i]));
    const theta = K.map(k => k / ro1);

    const xcp = xr.map((x,i) => x + K[i]);
    const ycp = yr.slice();

    const mask = xcp.map((x,i) => {
      const y = ycp[i];
      const rA1 = Math.hypot(x, y + ro1);
      const rA2 = Math.hypot(x, y - ro2);
      return (rA1 <= ra1) && (rA2 <= ra2);
    });

    const runs = [];
    let inRun = false, s = 0;
    for (let i=0;i<mask.length;i++){
      if (!inRun && mask[i]){ inRun = true; s = i; }
      if (inRun && (!mask[i] || i === mask.length-1)){
        const e = (mask[i] && i===mask.length-1) ? i : i-1;
        runs.push([s,e]);
        inRun = false;
      }
    }
    if (runs.length === 0) throw new Error("LOA extraction failed (no valid contact segment).");

    let best = runs[0], bestLen = -1;
    for (const [a,b] of runs){
      let L = 0;
      for (let k=a;k<b;k++){
        L += Math.hypot(xcp[k+1]-xcp[k], ycp[k+1]-ycp[k]);
      }
      if (L > bestLen){ bestLen = L; best = [a,b]; }
    }

    const [i0,i1] = best;
    const xLOA = xcp.slice(i0, i1+1);
    const yLOA = ycp.slice(i0, i1+1);
    const thLOA = theta.slice(i0, i1+1);
    const KLOA  = K.slice(i0, i1+1);

    const xPP = new Array(xLOA.length);
    const yPP = new Array(yLOA.length);
    for (let i=0;i<xLOA.length;i++){
      const x = xLOA[i], y = yLOA[i], th = thLOA[i];
      xPP[i] =  x*Math.cos(th) - (y + ro1)*Math.sin(th);
      yPP[i] =  x*Math.sin(th) + (y + ro1)*Math.cos(th) - ro1;
    }

    return {
      m, z1, z2, alphaRad, Ck, Cf, x1, x2,
      ro1, ro2, rb1, rb2, ra1, ra2, rf1, rf2,
      xLOA, yLOA, thLOA, KLOA,
      xrLOA: xLOA.map((x,i)=> x - KLOA[i]),
      yrLOA: yLOA.slice(),
      xPP, yPP
    };
  }

  // ----------------------
  // Rack fillet + generator (same as before)
  // ----------------------
  function eval_rc_from_dy(dy_try, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy){
    const yrl = y_end0 - dy_try;
    const xrl = x_end0 + slope_dxdy*(yrl - y_end0);
    const phir = phir0;

    let rc = (yrl + Math.tan(phir)*xrl + Cf*m - Math.tan(phir)*(K0 - delta0/2)) /
             (1 - Math.cos(phir) - Math.tan(phir)*Math.sin(phir));

    const yrend = rc*(1 - Math.cos(phir)) - Cf*m;
    if (yrend > yrl) rc = (yrl + Cf*m) / (1 - Math.cos(phir));

    const xtest = (-Cf*m - yrl - Math.tan(phir)*xrl) / (-Math.tan(phir));
    const useLowerLine = (xtest > K0);

    if (useLowerLine){
      const yrpr = yrl - offset*m;
      const xrpr = (yrpr - yrl - Math.tan(phir)*xrl) / (-Math.tan(phir));
      rc = (yrpr + Math.tan(phir_new)*xrpr + Cf*m - Math.tan(phir_new)*(K0 - delta0/2)) /
           (1 - Math.cos(phir_new) - Math.tan(phir_new)*Math.sin(phir_new));
    }
    return rc;
  }

  function rack_fillet_v2(m, Z, xr_in, yr_in, Cf, cdel, rc_target, phir_new, offset){
    let xr = xr_in.slice();
    let yr = yr_in.slice();
    if (xr.length !== yr.length || xr.length < 2) throw new Error("rack_fillet: invalid input.");
    if (yr[yr.length-1] > yr[0]){ xr.reverse(); yr.reverse(); }

    const dx_last = xr[xr.length-1] - xr[xr.length-2];
    const dy_last = yr[yr.length-1] - yr[yr.length-2];
    if (Math.abs(dy_last) < 1e-12) throw new Error("rack_fillet: dy‚âà0.");

    const slope_dxdy = dx_last / dy_last;
    const x_end0 = xr[xr.length-1];
    const y_end0 = yr[yr.length-1];

    const ro = m*Z/2;
    const theta_rack_0 = 0.495*Math.PI/Z;
    const K0 = theta_rack_0*ro + 0.495*Math.PI*m/2;
    const delta0 = cdel*m;

    const arack_end0 = (yr[yr.length-2] - yr[yr.length-1]) / (xr[yr.length-2] - xr[yr.length-1]);
    const phir0 = Math.atan(-arack_end0);

    let dy_ext = 0;
    if (!(isFinite(rc_target) && rc_target > 0)){
      dy_ext = 0.15*m;
    } else {
      const tol_rc = 1e-6*Math.max(1, Math.abs(rc_target));
      const max_iter = 45;

      let dy_lo = 0.0;
      let f_lo = eval_rc_from_dy(dy_lo, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;

      let dy_hi = 0.15*m;
      let f_hi = eval_rc_from_dy(dy_hi, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;

      const dy_hi_max = 20*m;
      let k_expand = 0;
      while ((f_lo*f_hi > 0) && (dy_hi < dy_hi_max) && (k_expand < 30)){
        dy_hi = Math.min(dy_hi*1.6 + 1e-6, dy_hi_max);
        f_hi = eval_rc_from_dy(dy_hi, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;
        k_expand++;
      }

      if (f_lo*f_hi <= 0){
        for (let it=0; it<max_iter; it++){
          const dy_mid = 0.5*(dy_lo + dy_hi);
          const f_mid = eval_rc_from_dy(dy_mid, m, Cf, offset, phir_new, K0, delta0, phir0, x_end0, y_end0, slope_dxdy) - rc_target;
          if (Math.abs(f_mid) < tol_rc || Math.abs(dy_hi-dy_lo) < 1e-10){ dy_ext = dy_mid; break; }
          if (f_lo*f_mid <= 0) dy_hi = dy_mid;
          else { dy_lo = dy_mid; f_lo = f_mid; }
          dy_ext = dy_mid;
        }
      } else {
        dy_ext = 0.15*m;
      }
    }

    if (dy_ext > 1e-12){
      const y_end1 = y_end0 - dy_ext;
      const stepext = 1.5e-3;
      const Next = Math.max(5, Math.ceil(Math.abs(y_end1 - y_end0)/stepext));
      const y_ext = linspace(y_end0, y_end1, Next+1).slice(1);
      const x_ext = y_ext.map(yv => xr[xr.length-1] + slope_dxdy*(yv - y_end0));
      xr = xr.concat(x_ext);
      yr = yr.concat(y_ext);
    }

    const arack_end = (yr[yr.length-2] - yr[yr.length-1]) / (xr[yr.length-2] - xr[yr.length-1]);
    let phir = Math.atan(-arack_end);

    const xrlptc = xr[xr.length-1];
    const yrlptc = yr[yr.length-1];

    let delta = cdel*m;
    let rc = (yrlptc + Math.tan(phir)*xrlptc + Cf*m - Math.tan(phir)*(K0 - delta/2)) /
             (1 - Math.cos(phir) - Math.tan(phir)*Math.sin(phir));

    let yrc0 = -Cf*m + rc;
    let xrc0 = K0 - delta/2;

    let xrend = -rc*Math.sin(phir) + xrc0;
    let yrend =  rc*(1 - Math.cos(phir)) - Cf*m;

    if (yrend > yrlptc){
      yrend = yrlptc;
      xrend = xrlptc;
      rc = (yrlptc + Cf*m) / (1 - Math.cos(phir));
      delta = 2*(K0 - xrlptc - rc*Math.sin(phir));
      yrc0 = -Cf*m + rc;
      xrc0 = K0 - delta/2;
    }

    const xtest = (-Cf*m - yrlptc - Math.tan(phir)*xrlptc) / (-Math.tan(phir));
    const useLowerLine = (xtest > K0);

    let xrpr=NaN, yrpr=NaN;
    let phiArc = phir;

    if (useLowerLine){
      yrpr = yrlptc - offset*m;
      xrpr = (yrpr - yrlptc - Math.tan(phir)*xrlptc) / (-Math.tan(phir));

      rc = (yrpr + Math.tan(phir_new)*xrpr + Cf*m - Math.tan(phir_new)*(K0 - delta/2)) /
           (1 - Math.cos(phir_new) - Math.tan(phir_new)*Math.sin(phir_new));

      yrc0 = -Cf*m + rc;
      xrc0 = K0 - delta/2;

      xrend = -rc*Math.sin(phir_new) + xrc0;
      yrend =  rc*(1 - Math.cos(phir_new)) - Cf*m;
      phiArc = phir_new;
    }

    let xr_lin = [], yr_lin = [], dydx_lin = [];
    let steplin = 1.5e-3;
    if (Math.abs(yrlptc - yrend) < steplin) steplin = Math.abs(yrlptc - yrend)/5 + 1e-12;

    if (!useLowerLine){
      const ylin = [];
      for (let yv=yrlptc; yv>=yrend; yv-=steplin) ylin.push(yv);
      if (ylin.length===0 || ylin[ylin.length-1] !== yrend) ylin.push(yrend);

      const xlin = ylin.map(yv => (yv - (yrlptc + Math.tan(phir)*xrlptc)) / (-Math.tan(phir)));
      xr_lin = xlin;
      yr_lin = ylin;
      dydx_lin = ylin.map(() => -Math.tan(phir));
    } else {
      const ylin1 = [];
      for (let yv=yrlptc; yv>=yrpr; yv-=steplin) ylin1.push(yv);
      if (ylin1.length===0 || ylin1[ylin1.length-1] !== yrpr) ylin1.push(yrpr);
      const xlin1 = ylin1.map(yv => (yv - (yrlptc + Math.tan(phir)*xrlptc)) / (-Math.tan(phir)));

      let steplin2 = steplin;
      if (Math.abs(yrpr - yrend) < steplin2) steplin2 = Math.abs(yrpr - yrend)/5 + 1e-12;
      const ylin2 = [];
      for (let yv=yrpr; yv>=yrend; yv-=steplin2) ylin2.push(yv);
      if (ylin2.length===0 || ylin2[ylin2.length-1] !== yrend) ylin2.push(yrend);
      const xlin2 = ylin2.map(yv => (yv - (yrpr + Math.tan(phir_new)*xrpr)) / (-Math.tan(phir_new)));

      xr_lin = xlin1.concat(xlin2.slice(1));
      yr_lin = ylin1.concat(ylin2.slice(1));
      dydx_lin = ylin1.map(() => -Math.tan(phir)).concat(ylin2.slice(1).map(() => -Math.tan(phir_new)));
    }

    const dphi = deg2rad(0.5);
    const thrc = [];
    for (let t=phiArc; t>=0; t-=dphi) thrc.push(t);
    if (thrc.length===0 || thrc[thrc.length-1] !== 0) thrc.push(0);

    const xr_rc = thrc.map(t => -rc*Math.sin(t) + xrc0);
    const yr_rc = thrc.map(t => -rc*Math.cos(t) + yrc0);
    const dydx_rc = thrc.map(t => -Math.tan(t));

    const xr_tr = xr_lin.concat(xr_rc);
    const yr_tr = yr_lin.concat(yr_rc);
    const dydx_tr = dydx_lin.concat(dydx_rc);

    const x_pin_tr = new Array(xr_tr.length);
    const y_pin_tr = new Array(yr_tr.length);

    for (let i=0;i<xr_tr.length;i++){
      const K_tr = -(yr_tr[i]*dydx_tr[i] + xr_tr[i]);
      const th = K_tr / ro;
      x_pin_tr[i] = (xr_tr[i] + K_tr)*Math.cos(th) - (yr_tr[i] + ro)*Math.sin(th);
      y_pin_tr[i] = (xr_tr[i] + K_tr)*Math.sin(th) + (yr_tr[i] + ro)*Math.cos(th);
    }

    return { x_pin_tr, y_pin_tr };
  }

  function snapEndToStart(A, B, tol){
    if (!A || !B || A.length===0 || B.length===0) return [A,B];
    const pA = A[A.length-1];
    const pB = B[0];
    const gap = Math.hypot(pA[0]-pB[0], pA[1]-pB[1]);
    if (gap <= tol){
      const p = [0.5*(pA[0]+pB[0]), 0.5*(pA[1]+pB[1])];
      A[A.length-1] = p;
      B[0] = p;
    }
    return [A,B];
  }
  function dedupeConsecutive(P){
    if (!P || P.length<2) return P;
    const out = [P[0]];
    for (let i=1;i<P.length;i++){
      const a = out[out.length-1], b = P[i];
      if (a[0] !== b[0] || a[1] !== b[1]) out.push(b);
    }
    return out;
  }
  function prepend_connector_if_needed(x_in, y_in, xtr_in, ytr_in, Nbridge=25){
    if (!x_in.length || !xtr_in.length) return {xtr:xtr_in, ytr:ytr_in};
    const p_end = [x_in[x_in.length-1], y_in[y_in.length-1]];
    const p0 = [xtr_in[0], ytr_in[0]];
    const d = Math.hypot(p_end[0]-p0[0], p_end[1]-p0[1]);
    if (d < 1e-9) return {xtr:xtr_in, ytr:ytr_in};

    Nbridge = Math.max(5, Math.round(Nbridge));
    const xb = linspace(p_end[0], p0[0], Nbridge);
    const yb = linspace(p_end[1], p0[1], Nbridge);

    return {
      xtr: xb.slice(0,-1).concat(xtr_in),
      ytr: yb.slice(0,-1).concat(ytr_in)
    };
  }

  function gear_generator(x, y, x_tr, y_tr, Z){
    if (x.length < 2 || y.length < 2 || x.length !== y.length) throw new Error("gear_generator: invalid x,y.");
    if (x_tr.length < 2 || y_tr.length < 2 || x_tr.length !== y_tr.length) throw new Error("gear_generator: invalid x_tr,y_tr.");
    if (!(Z>=3 && Number.isInteger(Z))) throw new Error("Z must be integer >=3.");

    const r_in = x.map((vx,i)=> Math.hypot(vx,y[i]));
    if (r_in[0] < r_in[r_in.length-1]){ x = x.slice().reverse(); y = y.slice().reverse(); }
    const r_tr = x_tr.map((vx,i)=> Math.hypot(vx,y_tr[i]));
    if (r_tr[r_tr.length-1] > r_tr[0]){ x_tr = x_tr.slice().reverse(); y_tr = y_tr.slice().reverse(); }

    const th_tip_R = Math.atan2(x[0], y[0]);
    const th_tip_L = Math.atan2(-x[0], y[0]);
    const rA = Math.hypot(x[0], y[0]);

    const th_pin_div_k = 40;
    const th_k = linspace(th_tip_L, th_tip_R, th_pin_div_k+1);
    const xk = th_k.slice(1,-1).map(t => rA*Math.sin(t));
    const yk = th_k.slice(1,-1).map(t => rA*Math.cos(t));

    const rF = Math.hypot(x_tr[x_tr.length-1], y_tr[y_tr.length-1]);
    const th_root_R = Math.atan2(x_tr[x_tr.length-1], y_tr[y_tr.length-1]);
    const th_root_L = Math.atan2(-x_tr[x_tr.length-1], y_tr[y_tr.length-1]);
    const th_root_L_next = th_root_L + 2*Math.PI/Z;

    const th_div_f = 20;
    const th_f = linspace(th_root_R, th_root_L_next, th_div_f+1);
    const xf = th_f.slice(1,-1).map(t => rF*Math.sin(t));
    const yf = th_f.slice(1,-1).map(t => rF*Math.cos(t));

    const x_tooth_legacy = [];
    const y_tooth_legacy = [];
    for (let i=x_tr.length-1;i>=0;i--){ x_tooth_legacy.push(-x_tr[i]); y_tooth_legacy.push(y_tr[i]); }
    for (let i=x.length-1;i>=0;i--){ x_tooth_legacy.push(-x[i]); y_tooth_legacy.push(y[i]); }
    for (let i=0;i<xk.length;i++){ x_tooth_legacy.push(xk[i]); y_tooth_legacy.push(yk[i]); }
    for (let i=0;i<x.length;i++){ x_tooth_legacy.push(x[i]); y_tooth_legacy.push(y[i]); }
    for (let i=0;i<x_tr.length;i++){ x_tooth_legacy.push(x_tr[i]); y_tooth_legacy.push(y_tr[i]); }
    for (let i=0;i<xf.length;i++){ x_tooth_legacy.push(xf[i]); y_tooth_legacy.push(yf[i]); }

    const Ntooth = x_tooth_legacy.length;
    const x_tot = new Array(Z*Ntooth + 1);
    const y_tot = new Array(Z*Ntooth + 1);

    for (let k=1;k<=Z;k++){
      const rot = -(k-1)*2*Math.PI/Z;
      const c = Math.cos(rot), s = Math.sin(rot);
      const istart = (k-1)*Ntooth;
      for (let i=0;i<Ntooth;i++){
        const xx = x_tooth_legacy[i], yy = y_tooth_legacy[i];
        x_tot[istart+i] = xx*c - yy*s;
        y_tot[istart+i] = xx*s + yy*c;
      }
    }
    x_tot[x_tot.length-1] = x_tot[0];
    y_tot[y_tot.length-1] = y_tot[0];

    const thetaB_L = -Math.PI/Z;
    const thetaB_R =  Math.PI/Z;

    const th_tip_L2  = Math.atan2(-x[0], y[0]);
    const th_tip_R2  = Math.atan2( x[0], y[0]);
    const th_root_R2 = Math.atan2( x_tr[x_tr.length-1], y_tr[y_tr.length-1]);

    const NrootSeg = 40;
    const NaddSeg  = 80;

    let seg = {};
    seg.rootL = arcXY(rF, thetaB_L, Math.atan2(-x_tr[x_tr.length-1], y_tr[y_tr.length-1]), NrootSeg, true);
    seg.troL  = x_tr.slice().reverse().map((vx,i)=> [-vx, y_tr[y_tr.length-1-i]]);
    seg.invL  = x.slice().reverse().map((vx,i)=> [-vx, y[y.length-1-i]]);
    seg.add   = arcXY(rA, th_tip_L2, th_tip_R2, NaddSeg, true);
    seg.invR  = x.map((vx,i)=> [vx, y[i]]);
    seg.troR  = x_tr.map((vx,i)=> [vx, y_tr[i]]);
    seg.rootR = arcXY(rF, th_root_R2, thetaB_R, NrootSeg, true);

    const tolSnap = Math.max(1e-6, 1e-3*Math.max(1, rA));
    [seg.rootL, seg.troL ] = snapEndToStart(seg.rootL, seg.troL,  tolSnap);
    [seg.troL,  seg.invL ] = snapEndToStart(seg.troL,  seg.invL,  tolSnap);
    [seg.invL,  seg.add  ] = snapEndToStart(seg.invL,  seg.add,   tolSnap);
    [seg.add,   seg.invR ] = snapEndToStart(seg.add,   seg.invR,  tolSnap);
    [seg.invR,  seg.troR ] = snapEndToStart(seg.invR,  seg.troR,  tolSnap);
    [seg.troR,  seg.rootR] = snapEndToStart(seg.troR,  seg.rootR, tolSnap);

    for (const k of ["rootL","troL","invL","add","invR","troR","rootR"]){
      seg[k] = dedupeConsecutive(seg[k]);
    }

    return { x_tot, y_tot, seg };
  }

  function mapRackFlankToGear(xr, yr, alphaRad, ro){
    const dydx = -1/Math.tan(alphaRad);
    const xg = new Array(xr.length);
    const yg = new Array(xr.length);
    for (let i=0;i<xr.length;i++){
      const K = -(yr[i]*dydx + xr[i]);
      const th = K / ro;
      xg[i] = (xr[i] + K)*Math.cos(th) - (yr[i] + ro)*Math.sin(th);
      yg[i] = (xr[i] + K)*Math.sin(th) + (yr[i] + ro)*Math.cos(th);
    }
    return {x:xg, y:yg};
  }

  // ----------------------
  // Drawing (Geometry pages) ‚Äî same as before
  // ----------------------
  function drawToothCanvas(cv, base, tooth, full, opts){
    const {ctx, cssW, cssH} = setupHiDPICanvas(cv);

    if (!base || !tooth){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.font = "14px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("‚Äî", 18, 28);
      ctx.restore();
      return;
    }

    const showFull = ui.showGear.checked && !!full;
    const showLOA  = ui.showLOA.checked && !!opts?.loa && !!opts?.isPinion;

    const pts = [];
    if (showFull){
      for (let i=0;i<full.x_tot.length;i++) pts.push([full.x_tot[i], full.y_tot[i]]);
    } else {
      for (let i=0;i<tooth.x_tooth.length;i++) pts.push([tooth.x_tooth[i], tooth.y_tooth[i]]);
    }

    let xmin=+Infinity, xmax=-Infinity, ymin=+Infinity, ymax=-Infinity;
    for (const [x,y] of pts){
      xmin = Math.min(xmin,x); xmax = Math.max(xmax,x);
      ymin = Math.min(ymin,y); ymax = Math.max(ymax,y);
    }
    if (showLOA){
      const xL = opts.loa.x, yL = opts.loa.y;
      for (let i=0;i<xL.length;i++){
        xmin = Math.min(xmin, xL[i]); xmax = Math.max(xmax, xL[i]);
        ymin = Math.min(ymin, yL[i]); ymax = Math.max(ymax, yL[i]);
      }
    }

    const w = Math.max(1e-9, xmax-xmin), h = Math.max(1e-9, ymax-ymin);
    const pad = 16;
    const s = Math.min((cssW-2*pad)/w, (cssH-2*pad)/h);

    const cx = pad + (cssW-2*pad)/2;
    const cy = pad + (cssH-2*pad)/2;
    const mx = 0.5*(xmin+xmax);
    const my = 0.5*(ymin+ymax);

    function X(x){ return cx + (x-mx)*s; }
    function Y(y){ return cy - (y-my)*s; }

    ctx.save();
    ctx.lineWidth = 2.2;
    ctx.strokeStyle = opts.color;
    ctx.beginPath();
    for (let i=0;i<pts.length;i++){
      const [x,y] = pts[i];
      if (i===0) ctx.moveTo(X(x),Y(y));
      else ctx.lineTo(X(x),Y(y));
    }
    ctx.stroke();
    ctx.restore();

    if (showLOA){
      const xL = opts.loa.x, yL = opts.loa.y;
      ctx.save();
      ctx.lineWidth = 2.0;
      ctx.strokeStyle = "rgba(61,220,151,.82)";
      ctx.beginPath();
      for (let i=0;i<xL.length;i++){
        if (i===0) ctx.moveTo(X(xL[i]), Y(yL[i]));
        else ctx.lineTo(X(xL[i]), Y(yL[i]));
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawGeometryDual(){
    const b = state.base;
    const loa = state.oper ? {x: state.oper.xLOA, y: state.oper.yLOA} : null;

    drawToothCanvas(ui.cvPinion, b, state.pinionTooth, state.pinionFull, {
      color: "rgba(122,162,255,.95)",
      isPinion: true,
      loa
    });

    drawToothCanvas(ui.cvGear, b, state.gearTooth, state.gearFull, {
      color: "rgba(255,107,107,.95)",
      isPinion: false
    });
  }

  function drawMeshView(){
    const {ctx, cssW, cssH} = setupHiDPICanvas(ui.cvMesh);

    if (!state.base || !state.pinionFull || !state.gearFull || !state.oper){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.font = "14px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("‚Äî", 18, 28);
      ctx.restore();
      return;
    }

    const base = state.base;
    const oper = state.oper;
    const a_w = oper.a12;
    const gearRot = Math.PI + (Math.PI / base.z2);

    function transformXY(x, y, rot, tx, ty){
      const c = Math.cos(rot), s = Math.sin(rot);
      return [x*c - y*s + tx, x*s + y*c + ty];
    }

    const pinPts = [];
    for (let i=0;i<state.pinionFull.x_tot.length;i++){
      pinPts.push([state.pinionFull.x_tot[i], state.pinionFull.y_tot[i]]);
    }

    const gearPts = [];
    for (let i=0;i<state.gearFull.x_tot.length;i++){
      const x = state.gearFull.x_tot[i];
      const y = state.gearFull.y_tot[i];
      gearPts.push(transformXY(x, y, gearRot, 0, a_w));
    }

    let xmin=+Infinity, xmax=-Infinity, ymin=+Infinity, ymax=-Infinity;
    function expand(pts){
      for (const [x,y] of pts){
        xmin = Math.min(xmin,x); xmax = Math.max(xmax,x);
        ymin = Math.min(ymin,y); ymax = Math.max(ymax,y);
      }
    }
    expand(pinPts); expand(gearPts);

    xmin = Math.min(xmin, -base.ra1, -base.ra2);
    xmax = Math.max(xmax,  base.ra1,  base.ra2);
    ymin = Math.min(ymin, -base.ra1,  a_w - base.ra2);
    ymax = Math.max(ymax,  base.ra1,  a_w + base.ra2);

    const pad = 18;

    const xP = 0;
    const yP = oper.rw1;

    const dxMax = Math.max(Math.abs(xmax - xP), Math.abs(xmin - xP));
    const dyMax = Math.max(Math.abs(ymax - yP), Math.abs(ymin - yP));
    const sFit = Math.min(
      (cssW/2 - pad) / Math.max(1e-9, dxMax),
      (cssH/2 - pad) / Math.max(1e-9, dyMax)
    );

    const s = sFit * state.view.zoom;
    const cx = cssW/2 + state.view.panX;
    const cy = cssH/2 + state.view.panY;

    function X(x){ return cx + (x - xP)*s; }
    function Y(y){ return cy - (y - yP)*s; }

    function drawCircleWorld(r, x0, y0){
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = 1;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.arc(X(x0), Y(y0), Math.max(0,r*s), 0, 2*Math.PI);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    drawCircleWorld(base.ra1, 0, 0);
    drawCircleWorld(oper.rw1, 0, 0);
    drawCircleWorld(base.rf1, 0, 0);

    drawCircleWorld(base.ra2, 0, a_w);
    drawCircleWorld(oper.rw2, 0, a_w);
    drawCircleWorld(base.rf2, 0, a_w);

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.08)";
    ctx.lineWidth = 1;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(X(0), Y(0));
    ctx.lineTo(X(0), Y(a_w));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    function drawPolyline(pts, color){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2.25;
      ctx.beginPath();
      for (let i=0;i<pts.length;i++){
        const [x,y] = pts[i];
        const px = X(x), py = Y(y);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }

    drawPolyline(pinPts, "rgba(122,162,255,.95)");
    drawPolyline(gearPts, "rgba(255,107,107,.95)");

    if (ui.showLOA.checked && oper){
      ctx.save();
      ctx.strokeStyle = "rgba(61,220,151,.80)";
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      for (let i=0;i<oper.xLOA.length;i++){
        const px = X(oper.xLOA[i]);
        const py = Y(oper.yLOA[i]);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  // ----------------------
  // AGMA + ISO + strength diagrams + exports + generation lab + compute + events

  // ----------------------

  // ----------------------
  // AGMA
  // ----------------------
  const matPresets = {
    steel250: {St: 430, Sc: 1100, E: 206000, nu: 0.30},
    steel300: {St: 520, Sc: 1250, E: 206000, nu: 0.30},
    carb:     {St: 900, Sc: 2000, E: 206000, nu: 0.30},
    nitr:     {St: 800, Sc: 1600, E: 206000, nu: 0.30},
    castiron: {St: 220, Sc: 650,  E: 170000, nu: 0.26},
    bronze:   {St: 260, Sc: 800,  E: 110000, nu: 0.34}
  };

  function applyMaterialPreset(){
    const key = ui.agmaMat.value;
    const p = matPresets[key] || matPresets.steel250;
    ui.agmaSt.value = String(p.St);
    ui.agmaSc.value = String(p.Sc);
    ui.agmaE.value  = String(p.E);
    ui.agmaNu.value = String(p.nu);
  }

  function lewisApproxY20FD(z){
    const y = 0.154 - 0.912/Math.max(3, z);
    return clamp(y, 0.05, 0.60);
  }
  function autoComputeJBoth(){
    if (!state.base) return;
    ui.agmaJ1.value = fmt(lewisApproxY20FD(state.base.z1), 3);
    ui.agmaJ2.value = fmt(lewisApproxY20FD(state.base.z2), 3);
  }
  function autoComputeI(){
    if (!state.base) return;
    const base = state.base;
    const phi = base.alphaRad;
    const mN = parseFloat(ui.agmaMN.value);
    const mG = base.z2 / base.z1;
    const I = (Math.cos(phi)*Math.sin(phi) / (2*Math.max(1e-9,mN))) * (mG/(mG+1));
    ui.agmaI.value = fmt(clamp(I, 0.02, 0.30), 3);
  }
  function computeZE(E, nu){
    const denom = Math.PI * ( 2*(1 - nu*nu)/Math.max(1e-9, E) );
    return Math.sqrt(1/Math.max(1e-12, denom));
  }

  function computeAGMAAll(){
    if (!state.base) return null;

    const base = state.base;
    const m = base.m;
    const b = parseFloat(ui.b.value);
    const T = parseFloat(ui.torque.value);
    if (!(isFinite(b) && b>0)) throw new Error("AGMA: b must be > 0.");
    if (!(isFinite(T) && T>0)) throw new Error("AGMA: T must be > 0.");

    const Ko = parseFloat(ui.agmaKo.value);
    const Kv = parseFloat(ui.agmaKv.value);
    const Ks = parseFloat(ui.agmaKs.value);
    const KH = parseFloat(ui.agmaKH.value);
    const KB = parseFloat(ui.agmaKB.value);
    const ZR = parseFloat(ui.agmaZR.value);

    const J1  = parseFloat(ui.agmaJ1.value);
    const J2  = parseFloat(ui.agmaJ2.value);
    const I   = parseFloat(ui.agmaI.value);

    const St = parseFloat(ui.agmaSt.value);
    const Sc = parseFloat(ui.agmaSc.value);
    const E  = parseFloat(ui.agmaE.value);
    const nu = parseFloat(ui.agmaNu.value);

    const YN = parseFloat(ui.agmaYN.value);
    const ZN = parseFloat(ui.agmaZN.value);
    const YT = parseFloat(ui.agmaYT.value);
    const YZ = parseFloat(ui.agmaYZ.value);
    const ZW = parseFloat(ui.agmaZW.value);

    const SF = parseFloat(ui.agmaSF.value);
    const SH = parseFloat(ui.agmaSH.value);

    const r1_m = (base.ro1 * 1e-3);
    const Wt = T / Math.max(1e-12, r1_m);

    const sigmaF1 = (Wt * Ko * Kv * Ks * KH * KB) / (Math.max(1e-9, b) * Math.max(1e-9, m) * Math.max(1e-9, J1));
    const sigmaF2 = (Wt * Ko * Kv * Ks * KH * KB) / (Math.max(1e-9, b) * Math.max(1e-9, m) * Math.max(1e-9, J2));

    const dp = base.m * base.z1;
    const ZE = computeZE(E, nu);
    const sigmaH = ZE * Math.sqrt(
      (Wt * Ko * Kv * Ks * KH * ZR) / (Math.max(1e-9, b) * Math.max(1e-9, dp) * Math.max(1e-9, I))
    );

    const sigF_allow = (St * YN) / (Math.max(1e-9, YT) * Math.max(1e-9, YZ) * Math.max(1e-9, SF));
    const sigH_allow = (Sc * ZN * ZW) / (Math.max(1e-9, YT) * Math.max(1e-9, YZ) * Math.max(1e-9, SH));

    const SFF1 = sigF_allow / Math.max(1e-12, sigmaF1);
    const SFF2 = sigF_allow / Math.max(1e-12, sigmaF2);
    const SFH  = sigH_allow / Math.max(1e-12, sigmaH);

    const passF1 = sigmaF1 <= sigF_allow + 1e-9;
    const passF2 = sigmaF2 <= sigF_allow + 1e-9;
    const passH  = sigmaH  <= sigH_allow + 1e-9;

    return {
      mesh: {sigmaH, sigH_allow, SFH, passH},
      pinion: {sigmaF: sigmaF1, sigF_allow, SFF: SFF1, passF: passF1},
      gear:   {sigmaF: sigmaF2, sigF_allow, SFF: SFF2, passF: passF2},
      passAll: (passF1 && passF2 && passH)
    };
  }

  // ----------------------
  // ISO 6336
  // ----------------------
  function applyISOMaterialPreset(){
    const key = ui.isoMat.value;
    const p = matPresets[key] || matPresets.steel250;
    ui.isoFlim.value = String(p.St);
    ui.isoHlim.value = String(p.Sc);
    ui.isoE.value  = String(p.E);
    ui.isoNu.value = String(p.nu);
  }

  function autoComputeISOY(){
    if (!state.base) return;
    const y1 = lewisApproxY20FD(state.base.z1);
    const y2 = lewisApproxY20FD(state.base.z2);
    const YSdef = 1.50;
    const YF1 = (1/Math.max(1e-9, y1)) / YSdef;
    const YF2 = (1/Math.max(1e-9, y2)) / YSdef;
    ui.isoYS1.value = fmt(YSdef,2);
    ui.isoYS2.value = fmt(YSdef,2);
    ui.isoYF1.value = fmt(YF1,2);
    ui.isoYF2.value = fmt(YF2,2);
  }

  function computeZE_ISO(E1, nu1, E2, nu2){
    const t = (1 - nu1*nu1)/Math.max(1e-9, E1) + (1 - nu2*nu2)/Math.max(1e-9, E2);
    const denom = Math.PI * Math.max(1e-18, t);
    return Math.sqrt(1/denom);
  }

  function computeZeps_spur(epsAlpha, conservative){
    if (!isFinite(epsAlpha) || epsAlpha <= 0) return 1.0;
    if (conservative && epsAlpha < 2.0) return 1.0;
    const ea = clamp(epsAlpha, 1.0, 3.99);
    const val = (4 - ea)/3;
    return Math.sqrt(Math.max(1e-12, val));
  }

  function computeZB_ZD_spur({z1,z2,da1,da2,db1,db2,alphaW,epsAlpha}){
    if (!(epsAlpha > 1)) return {ZB:1, ZD:1, M1:1, M2:1};

    function safeA(da, db, z, useEpsTerm){
      const r = (da*da)/(Math.max(1e-12, db*db));
      const term = useEpsTerm ? ((epsAlpha - 1)*2*Math.PI/Math.max(3,z)) : (2*Math.PI/Math.max(3,z));
      return (r - 1 - term);
    }

    const A1 = safeA(da1, db1, z1, false);
    const B1 = safeA(da2, db2, z2, true);

    const A2 = safeA(da2, db2, z2, false);
    const B2 = safeA(da1, db1, z1, true);

    function M(A,B){
      const prod = A*B;
      if (!(prod > 1e-12) || !isFinite(prod)) return 1.0;
      const den = Math.sqrt(Math.sqrt(prod));
      return Math.tan(alphaW)/Math.max(1e-12, den);
    }

    const M1 = M(A1,B1);
    const M2 = M(A2,B2);

    return {
      M1, M2,
      ZB: (M1 > 1) ? M1 : 1,
      ZD: (M2 > 1) ? M2 : 1
    };
  }

  function computeISOAll(){
    if (!state.base || !state.oper) return null;

    const base = state.base;
    const oper = state.oper;

    const b = parseFloat(ui.b.value);
    const T = parseFloat(ui.torque.value);
    if (!(isFinite(b) && b>0)) throw new Error("ISO: b must be > 0.");
    if (!(isFinite(T) && T>0)) throw new Error("ISO: T must be > 0.");

    const r1_m = (base.ro1 * 1e-3);
    const Ft = T / Math.max(1e-12, r1_m);

    const z1 = base.z1, z2 = base.z2;
    const u = z2 / Math.max(1e-12, z1);

    const d1 = oper.d01;
    const da1 = oper.dk1;
    const da2 = oper.dk2;
    const db1 = oper.dg1;
    const db2 = oper.dg2;

    const alpha_t = base.alphaRad;
    const alphaW  = oper.alphaW;

    const KA = parseFloat(ui.isoKA.value);
    const Kv = parseFloat(ui.isoKv.value);

    const KHb = parseFloat(ui.isoKHb.value);
    const KHa = parseFloat(ui.isoKHa.value);

    const KFb = parseFloat(ui.isoKFb.value);
    const KFa = parseFloat(ui.isoKFa.value);

    const E = parseFloat(ui.isoE.value);
    const nu = parseFloat(ui.isoNu.value);

    const ZE = computeZE_ISO(E,nu,E,nu);

    const ZH = Math.sqrt(
      (2*Math.cos(0)*Math.cos(alphaW)) /
      (Math.max(1e-12, Math.cos(alpha_t)*Math.cos(alpha_t)) * Math.max(1e-12, Math.sin(alphaW)))
    );

    const Zeps = computeZeps_spur(oper.eps, ui.isoConservativeZeps.checked);
    const Zbeta = 1.0;

    const {ZB, ZD} = computeZB_ZD_spur({z1,z2,da1,da2,db1,db2,alphaW,epsAlpha: oper.eps});

    const sigmaH0 = ZE * ZH * Zeps * Zbeta * Math.sqrt(
      (Ft*(u+1)) / (Math.max(1e-12, b) * Math.max(1e-12, d1) * Math.max(1e-12, u))
    );

    const KHp = Math.sqrt(Math.max(1e-12, KA*Kv*KHb*KHa));
    const sigmaH1 = ZB * sigmaH0 * KHp;
    const sigmaH2 = ZD * sigmaH0 * KHp;

    const sigmaHlim = parseFloat(ui.isoHlim.value);
    const ZN = parseFloat(ui.isoZN.value);
    const ZL = parseFloat(ui.isoZL.value);
    const ZR = parseFloat(ui.isoZR2.value);
    const ZV = parseFloat(ui.isoZV.value);
    const ZW = parseFloat(ui.isoZW2.value);
    const ZX = parseFloat(ui.isoZX.value);
    const SH = parseFloat(ui.isoSH.value);

    const sigHP = (sigmaHlim * ZN * ZL * ZR * ZV * ZW * ZX) / Math.max(1e-12, SH);

    const SH1 = sigHP / Math.max(1e-12, sigmaH1);
    const SH2 = sigHP / Math.max(1e-12, sigmaH2);

    const mn = base.m;
    const YF1 = parseFloat(ui.isoYF1.value);
    const YF2 = parseFloat(ui.isoYF2.value);
    const YS1 = parseFloat(ui.isoYS1.value);
    const YS2 = parseFloat(ui.isoYS2.value);

    const Ybeta = 1.0;
    const YB = 1.0;
    const YDT = 1.0;

    const sigmaF01 = (Ft/(Math.max(1e-12,b)*Math.max(1e-12,mn))) * YF1 * YS1 * Ybeta * YB * YDT;
    const sigmaF02 = (Ft/(Math.max(1e-12,b)*Math.max(1e-12,mn))) * YF2 * YS2 * Ybeta * YB * YDT;

    const sigmaF1 = sigmaF01 * (KA*Kv*KFb*KFa);
    const sigmaF2 = sigmaF02 * (KA*Kv*KFb*KFa);

    const sigmaFlim = parseFloat(ui.isoFlim.value);
    const YST = parseFloat(ui.isoYST.value);
    const YNT = parseFloat(ui.isoYNT.value);
    const Ydel = parseFloat(ui.isoYdel.value);
    const YRr = parseFloat(ui.isoYR.value);
    const YX = parseFloat(ui.isoYX.value);
    const SF = parseFloat(ui.isoSF.value);

    const sigFP = (sigmaFlim * YST * YNT * Ydel * YRr * YX) / Math.max(1e-12, SF);

    const SF1 = sigFP / Math.max(1e-12, sigmaF1);
    const SF2 = sigFP / Math.max(1e-12, sigmaF2);

    const passF1 = sigmaF1 <= sigFP + 1e-9;
    const passF2 = sigmaF2 <= sigFP + 1e-9;
    const passH1 = sigmaH1 <= sigHP + 1e-9;
    const passH2 = sigmaH2 <= sigHP + 1e-9;

    return {
      contact: {sigmaH0, sigmaH1, sigmaH2, sigHP, SH1, SH2, passH1, passH2, ZE, ZH, Zeps, ZB, ZD},
      pinion: {sigmaF: sigmaF1, sigFP, SF: SF1, passF: passF1},
      gear:   {sigmaF: sigmaF2, sigFP, SF: SF2, passF: passF2},
      passAll: (passF1 && passF2 && passH1 && passH2)
    };
  }

  // ----------------------
  // Strength diagrams (same as before)
  // ----------------------
  function drawStrengthDiagramMember(cv, title, agmaMember, isoMember, agmaMesh, isoContactForMember){
    const {ctx, cssW, cssH} = setupHiDPICanvas(cv);

    if (!agmaMember && !isoMember){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.font = "14px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("‚Äî", 18, 28);
      ctx.restore();
      return;
    }

    const vals = [];
    if (agmaMember) vals.push(agmaMember.sigmaF, agmaMember.sigF_allow);
    if (isoMember)  vals.push(isoMember.sigmaF, isoMember.sig_allow);
    if (agmaMesh)   vals.push(agmaMesh.sigmaH, agmaMesh.sigH_allow);
    if (isoContactForMember) vals.push(isoContactForMember.sigmaH, isoContactForMember.sig_allow);

    const maxV = Math.max(...vals.filter(v=>isFinite(v))) * 1.20;
    const rect = {x:70, y:26, w: cssW-90, h: cssH-86};
    function Y(v){ return rect.y + (1 - v/Math.max(1e-12,maxV))*rect.h; }

    ctx.save();
    const g = ctx.createLinearGradient(0, rect.y, 0, rect.y+rect.h);
    g.addColorStop(0, "rgba(255,255,255,.03)");
    g.addColorStop(1, "rgba(255,255,255,.01)");
    ctx.fillStyle = g;
    ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.lineWidth = 1;
    ctx.fillStyle = "rgba(255,255,255,.65)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for (let i=0;i<=5;i++){
      const a = i/5;
      const v = a*maxV;
      const py = rect.y + (1-a)*rect.h;
      ctx.beginPath(); ctx.moveTo(rect.x, py); ctx.lineTo(rect.x+rect.w, py); ctx.stroke();
      ctx.fillText(fmt(v,0), rect.x-8, py);
    }
    ctx.restore();

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    ctx.restore();

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.90)";
    ctx.font = "950 12px " + getComputedStyle(document.body).fontFamily;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText(title, rect.x, 6);

    ctx.textAlign = "right";
    ctx.fillStyle = "rgba(122,162,255,.95)";
    ctx.fillText("AGMA", rect.x+rect.w, 6);
    ctx.fillStyle = "rgba(180,124,255,.95)";
    ctx.fillText("  ISO", rect.x+rect.w, 20);
    ctx.restore();

    const gxB = rect.x + rect.w*0.32;
    const gxC = rect.x + rect.w*0.74;
    const barW = Math.min(56, rect.w*0.14);
    const off  = barW*0.35;

    function bar(xCenter, v, ok, color){
      const x = xCenter - barW/2;
      const y = Y(v);
      const h = (rect.y+rect.h) - y;

      ctx.save();
      ctx.shadowColor = "rgba(0,0,0,.45)";
      ctx.shadowBlur = 10;
      ctx.shadowOffsetY = 4;
      ctx.fillStyle = ok ? color : "rgba(255,107,107,.82)";
      ctx.fillRect(x, y, barW, h);
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+barW, y);
      ctx.stroke();
      ctx.restore();
    }

    function allowLine(xCenter, v, dashed){
      const y = Y(v);
      ctx.save();
      ctx.strokeStyle = "rgba(61,220,151,.92)";
      ctx.lineWidth = 2;
      if (dashed) ctx.setLineDash([6,5]);
      ctx.beginPath();
      ctx.moveTo(xCenter - barW*1.05, y);
      ctx.lineTo(xCenter + barW*1.05, y);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    function tag(x, y, txt, color){
      ctx.save();
      ctx.fillStyle = color || "rgba(255,255,255,.90)";
      ctx.font = "900 10.5px " + getComputedStyle(document.body).fontFamily;
      ctx.textAlign = "center";
      ctx.textBaseline = "bottom";
      ctx.fillText(txt, x, y);
      ctx.restore();
    }

    function bottomLabel(x, txt){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.78)";
      ctx.font = "900 11px " + getComputedStyle(document.body).fontFamily;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillText(txt, x, rect.y+rect.h+10);
      ctx.restore();
    }

    if (agmaMember){
      bar(gxB - off, agmaMember.sigmaF, agmaMember.passF, "rgba(122,162,255,.82)");
      allowLine(gxB, agmaMember.sigF_allow, false);
      tag(gxB - off, Y(agmaMember.sigmaF)-6, "œÉF=" + fmt(agmaMember.sigmaF,0), "rgba(122,162,255,.95)");
      tag(gxB, Y(agmaMember.sigF_allow)-6, "allow(A)=" + fmt(agmaMember.sigF_allow,0), "rgba(61,220,151,.92)");
    }
    if (isoMember){
      bar(gxB + off, isoMember.sigmaF, isoMember.pass, "rgba(180,124,255,.82)");
      allowLine(gxB, isoMember.sig_allow, true);
      tag(gxB + off, Y(isoMember.sigmaF)-6, "œÉF=" + fmt(isoMember.sigmaF,0), "rgba(180,124,255,.95)");
      tag(gxB, Y(isoMember.sig_allow)-18, "allow(I)=" + fmt(isoMember.sig_allow,0), "rgba(61,220,151,.92)");
    }
    bottomLabel(gxB, "Bending");

    if (agmaMesh){
      bar(gxC - off, agmaMesh.sigmaH, agmaMesh.passH, "rgba(122,162,255,.82)");
      allowLine(gxC, agmaMesh.sigH_allow, false);
      tag(gxC - off, Y(agmaMesh.sigmaH)-6, "œÉH=" + fmt(agmaMesh.sigmaH,0), "rgba(122,162,255,.95)");
      tag(gxC, Y(agmaMesh.sigH_allow)-6, "allow(A)=" + fmt(agmaMesh.sigH_allow,0), "rgba(61,220,151,.92)");
    }
    if (isoContactForMember){
      bar(gxC + off, isoContactForMember.sigmaH, isoContactForMember.pass, "rgba(180,124,255,.82)");
      allowLine(gxC, isoContactForMember.sig_allow, true);
      tag(gxC + off, Y(isoContactForMember.sigmaH)-6, "œÉH=" + fmt(isoContactForMember.sigmaH,0), "rgba(180,124,255,.95)");
      tag(gxC, Y(isoContactForMember.sig_allow)-18, "allow(I)=" + fmt(isoContactForMember.sig_allow,0), "rgba(61,220,151,.92)");
    }
    bottomLabel(gxC, "Contact");

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.70)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.translate(18, rect.y + rect.h/2);
    ctx.rotate(-Math.PI/2);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Stress [MPa]", 0, 0);
    ctx.restore();
  }

  function drawStrengthDiagrams(){
    const a = state.agma;
    const i = state.iso;

    if (!a && !i){
      drawStrengthDiagramMember(ui.cvAGMAPinion, "Pinion", null, null, null, null);
      drawStrengthDiagramMember(ui.cvAGMAGear, "Gear", null, null, null, null);
      return;
    }

    const isoPin = i ? {sigmaF: i.pinion.sigmaF, sig_allow: i.pinion.sigFP, pass: i.pinion.passF} : null;
    const isoGear = i ? {sigmaF: i.gear.sigmaF,   sig_allow: i.gear.sigFP,   pass: i.gear.passF} : null;

    const isoHpin = i ? {sigmaH: i.contact.sigmaH1, sig_allow: i.contact.sigHP, pass: i.contact.passH1} : null;
    const isoHger = i ? {sigmaH: i.contact.sigmaH2, sig_allow: i.contact.sigHP, pass: i.contact.passH2} : null;

    drawStrengthDiagramMember(ui.cvAGMAPinion, "Pinion", a ? a.pinion : null, isoPin, a ? a.mesh : null, isoHpin);
    drawStrengthDiagramMember(ui.cvAGMAGear,   "Gear",   a ? a.gear   : null, isoGear, a ? a.mesh : null, isoHger);
  }

  // ----------------------
  // Results + warnings UI
  // ----------------------
  function setExportsEnabledPinion(on){
    ui.btnCSV_Profile.disabled = !on;
    ui.btnCSV_Tooth.disabled = !on;
    ui.btnCSV_Gear.disabled = !on;
    ui.btnCSV_Segment.disabled = !on;
    ui.segSelect.disabled = !on;
  }
  function setExportsEnabledGear(on){
    ui.btnCSV_Tooth2.disabled = !on;
    ui.btnCSV_Gear2.disabled = !on;
    ui.btnCSV_Segment2.disabled = !on;
    ui.segSelect2.disabled = !on;
  }

  function undercutLabel(qc){
    if (!qc || !qc.uc1 || !qc.uc2) return {txt:"‚Äî", color:""};
    const u1 = qc.uc1.hasUndercut;
    const u2 = qc.uc2.hasUndercut;
    if (!u1 && !u2) return {txt:"OK", color:"var(--green)"};
    if (u1 && u2) return {txt:"UNDERCUT (both)", color:"var(--red)"};
    if (u1) return {txt:"UNDERCUT (pinion)", color:"var(--red)"};
    return {txt:"UNDERCUT (gear)", color:"var(--red)"};
  }

  function buildWarningsHTML(){
    if (!state.base || !state.qc || !state.oper) return "";

    const base = state.base;
    const qc = state.qc;

    const msgs = [];

    const thr = 0.2 * base.m;
    if (isFinite(qc.tip1) && qc.tip1 < thr){
      msgs.push(`‚ö†Ô∏è Pinion tip thickness is low: <span class="mono">s<sub>a1</sub>=${fmt(qc.tip1,3)}</span> mm (threshold <span class="mono">0.2¬∑m=${fmt(thr,3)}</span> mm).`);
    }
    if (isFinite(qc.tip2) && qc.tip2 < thr){
      msgs.push(`‚ö†Ô∏è Gear tip thickness is low: <span class="mono">s<sub>a2</sub>=${fmt(qc.tip2,3)}</span> mm (threshold <span class="mono">0.2¬∑m=${fmt(thr,3)}</span> mm).`);
    }

    if (qc.inter && (qc.inter.pinionInterference || qc.inter.gearInterference)){
      const parts = [];
      if (qc.inter.pinionInterference) parts.push(`pinion (min(r)‚àír<sub>b1</sub>=<span class="mono">${fmt(qc.inter.margin1,3)}</span> mm)`);
      if (qc.inter.gearInterference)   parts.push(`gear (min(r)‚àír<sub>b2</sub>=<span class="mono">${fmt(qc.inter.margin2,3)}</span> mm)`);
      msgs.push(`‚ö†Ô∏è Operating interference detected: contact goes below base circle for ${parts.join(" and ")}.`);
    }

    if (qc.uc1 && qc.uc1.hasUndercut){
      msgs.push(`‚ö†Ô∏è Manufacturing undercut likely (pinion): <span class="mono">z‚ÇÅ=${base.z1}</span> < <span class="mono">Zmin=${fmt(qc.uc1.Zmin,2)}</span> (with <span class="mono">x‚ÇÅ=${fmt(qc.uc1.x,2)}</span>, <span class="mono">C<sub>c</sub>=${fmt(qc.uc1.Cc,2)}</span>).`);
    }
    if (qc.uc2 && qc.uc2.hasUndercut){
      msgs.push(`‚ö†Ô∏è Manufacturing undercut likely (gear): <span class="mono">z‚ÇÇ=${base.z2}</span> < <span class="mono">Zmin=${fmt(qc.uc2.Zmin,2)}</span> (with <span class="mono">x‚ÇÇ=${fmt(qc.uc2.x,2)}</span>, <span class="mono">C<sub>c</sub>=${fmt(qc.uc2.Cc,2)}</span>).`);
    }

    if (msgs.length === 0) return "";
    return msgs.map(m => `‚Ä¢ ${m}`).join("<br>");
  }

  function updateKeyResults(){
    const base = state.base;
    const oper = state.oper;

    setVal(ui.res_aw,  oper ? fmt(rad2deg(oper.alphaW), 3) : "‚Äî");
    setVal(ui.res_a12, oper ? fmt(oper.a12, 3) : "‚Äî");

    setVal(ui.res_eps, oper ? fmt(oper.eps, 3) : "‚Äî");
    setVal(ui.res_loa, oper ? fmt(oper.L, 3) : "‚Äî");

    if (oper){
      setVal(ui.res_d0, fmtPair(oper.d01, oper.d02, 3));
      setVal(ui.res_dg, fmtPair(oper.dg1, oper.dg2, 3));
      setVal(ui.res_db, fmtPair(oper.db1, oper.db2, 3));
      setVal(ui.res_dk, fmtPair(oper.dk1, oper.dk2, 3));
      setVal(ui.res_df, fmtPair(oper.df1, oper.df2, 3));
    } else {
      setVal(ui.res_d0, "‚Äî");
      setVal(ui.res_dg, "‚Äî");
      setVal(ui.res_db, "‚Äî");
      setVal(ui.res_dk, "‚Äî");
      setVal(ui.res_df, "‚Äî");
    }

    if (base && state.qc){
      const thr = 0.2 * base.m;
      const tip1 = state.qc.tip1;
      const tip2 = state.qc.tip2;

      setVal(ui.res_tip1, isFinite(tip1) ? fmt(tip1, 3) : "‚Äî", (isFinite(tip1) && tip1 < thr) ? "var(--red)" : "");
      setVal(ui.res_tip2, isFinite(tip2) ? fmt(tip2, 3) : "‚Äî", (isFinite(tip2) && tip2 < thr) ? "var(--red)" : "");

      const inter = state.qc.inter;
      if (inter && (inter.pinionInterference || inter.gearInterference)){
        setVal(ui.res_interf, "INTERFERENCE", "var(--red)");
      } else if (inter){
        setVal(ui.res_interf, "OK", "var(--green)");
      } else {
        setVal(ui.res_interf, "‚Äî");
      }

      const u = undercutLabel(state.qc);
      setVal(ui.res_uc, u.txt, u.color);

    } else {
      setVal(ui.res_tip1, "‚Äî");
      setVal(ui.res_tip2, "‚Äî");
      setVal(ui.res_interf, "‚Äî");
      setVal(ui.res_uc, "‚Äî");
    }

    if (!state.agma){
      setVal(ui.res_agma, "‚Äî");
    } else {
      setVal(ui.res_agma, state.agma.passAll ? "PASS" : "FAIL", state.agma.passAll ? "var(--green)" : "var(--red)");
    }
    if (!state.iso){
      setVal(ui.res_iso, "‚Äî");
    } else {
      setVal(ui.res_iso, state.iso.passAll ? "PASS" : "FAIL", state.iso.passAll ? "var(--green)" : "var(--red)");
    }

    showErr(ui.warnBox, buildWarningsHTML());
  }

  function updateCSVInfoUI(){
    ui.segListInfo.innerHTML = "";
    const pinOK = !!(state.pinionFull && state.pinionTooth && state.pinionSeg);
    setExportsEnabledPinion(pinOK);

    if (!pinOK){
      ui.segListInfo.innerHTML = '<div class="kv"><div class="k">‚Äî</div><div class="v">‚Äî</div></div>';
    } else {
      const segList = ui.segListInfo;
      function addItem(name, count){
        const div = document.createElement("div");
        div.className = "kv";
        div.innerHTML = '<div class="k">'+name+'</div><div class="v">'+count+' pts</div>';
        segList.appendChild(div);
      }
      addItem("Profile (pitch-point frame)", state.lastProfilePP ? state.lastProfilePP.x_pp.length : 0);
      addItem("Tooth sector boundary", state.pinionTooth ? state.pinionTooth.x_tooth.length : 0);
      addItem("Full outline", state.pinionFull ? state.pinionFull.x_tot.length : 0);

      const map = {
        rootL:"01_rootCircle_L", troL:"02_trochoid_L", invL:"03_involute_L",
        add:"04_addendumArc", invR:"05_involute_R", troR:"06_trochoid_R", rootR:"07_rootCircle_R"
      };
      for (const k of Object.keys(map)){
        addItem(map[k], (state.pinionSeg[k] || []).length);
      }
    }

    ui.segListInfo2.innerHTML = "";
    const gearOK = !!(state.gearFull && state.gearTooth && state.gearSeg);
    setExportsEnabledGear(gearOK);

    if (!gearOK){
      ui.segListInfo2.innerHTML = '<div class="kv"><div class="k">‚Äî</div><div class="v">‚Äî</div></div>';
    } else {
      const segList2 = ui.segListInfo2;
      function addItem2(name, count){
        const div = document.createElement("div");
        div.className = "kv";
        div.innerHTML = '<div class="k">'+name+'</div><div class="v">'+count+' pts</div>';
        segList2.appendChild(div);
      }
      addItem2("Tooth sector boundary", state.gearTooth ? state.gearTooth.x_tooth.length : 0);
      addItem2("Full outline", state.gearFull ? state.gearFull.x_tot.length : 0);

      const map2 = {
        rootL:"01_rootCircle_L", troL:"02_trochoid_L", invL:"03_involute_L",
        add:"04_addendumArc", invR:"05_involute_R", troR:"06_trochoid_R", rootR:"07_rootCircle_R"
      };
      for (const k of Object.keys(map2)){
        addItem2(map2[k], (state.gearSeg[k] || []).length);
      }
    }
  }

  function updateStrengthUI(){
    const a = state.agma;
    const i = state.iso;

    if (!a && !i){
      ui.strength_sigF1.textContent = "‚Äî";
      ui.strength_sigF2.textContent = "‚Äî";
      ui.strength_sigH1.textContent = "‚Äî";
      ui.strength_sigH2.textContent = "‚Äî";
      ui.strength_SFs.textContent   = "‚Äî";
      drawStrengthDiagrams();
      return;
    }

    const agF1 = a ? a.pinion.sigmaF : NaN;
    const agF2 = a ? a.gear.sigmaF   : NaN;
    const agFall = a ? a.pinion.sigF_allow : NaN;
    const isF1 = i ? i.pinion.sigmaF : NaN;
    const isF2 = i ? i.gear.sigmaF   : NaN;
    const isFall = i ? i.pinion.sigFP : NaN;

    ui.strength_sigF1.textContent = `${fmt(agF1,1)} / ${fmt(isF1,1)} | ${fmt(agFall,1)} / ${fmt(isFall,1)}`;
    ui.strength_sigF2.textContent = `${fmt(agF2,1)} / ${fmt(isF2,1)} | ${fmt(agFall,1)} / ${fmt(isFall,1)}`;

    const agH = a ? a.mesh.sigmaH : NaN;
    const agHall = a ? a.mesh.sigH_allow : NaN;
    const isH1 = i ? i.contact.sigmaH1 : NaN;
    const isH2 = i ? i.contact.sigmaH2 : NaN;
    const isHall = i ? i.contact.sigHP : NaN;

    ui.strength_sigH1.textContent = `${fmt(agH,1)} / ${fmt(isH1,1)} | ${fmt(agHall,1)} / ${fmt(isHall,1)}`;
    ui.strength_sigH2.textContent = `${fmt(agH,1)} / ${fmt(isH2,1)} | ${fmt(agHall,1)} / ${fmt(isHall,1)}`;

    const agSFs = a ? `AGMA: SF‚ÇÅ=${fmt(a.pinion.SFF,2)} SF‚ÇÇ=${fmt(a.gear.SFF,2)} SH=${fmt(a.mesh.SFH,2)}` : "AGMA: ‚Äî";
    const isSFs = i ? `ISO: SF‚ÇÅ=${fmt(i.pinion.SF,2)} SF‚ÇÇ=${fmt(i.gear.SF,2)} SH‚ÇÅ=${fmt(i.contact.SH1,2)} SH‚ÇÇ=${fmt(i.contact.SH2,2)}` : "ISO: ‚Äî";
    ui.strength_SFs.textContent = agSFs + "  |  " + isSFs;

    drawStrengthDiagrams();
  }

  function updateAllUI(){
    updateKeyResults();
    updateCSVInfoUI();
    updateStrengthUI();
    ui.cutT.value = String(state.gen.t);
    ui.cutTtxt.textContent = fmt(state.gen.t, 3);
    ui.cutSpTxt.textContent = fmt(state.gen.speed, 2) + "√ó";
  }

  // ----------------------
  // CSV exports
  // ----------------------
  function exportProfileCSV(){
    if (!state.lastProfilePP) return;
    const {x_pp,y_pp} = state.lastProfilePP;
    const rows = [["idx","x_pp_mm","y_pp_mm"]];
    for (let i=0;i<x_pp.length;i++) rows.push([String(i+1), String(x_pp[i]), String(y_pp[i])]);
    downloadCSV("pinion_profile_pitch_point.csv", rows);
  }
  function exportToothCSV(){
    if (!state.pinionTooth) return;
    const {x_tooth,y_tooth} = state.pinionTooth;
    const rows = [["x_mm","y_mm"]];
    for (let i=0;i<x_tooth.length;i++) rows.push([String(x_tooth[i]), String(y_tooth[i])]);
    downloadCSV("tooth_outline_sector_pinion.csv", rows);
  }
  function exportGearCSV(){
    if (!state.pinionFull) return;
    const {x_tot,y_tot} = state.pinionFull;
    const rows = [["x_mm","y_mm"]];
    for (let i=0;i<x_tot.length;i++) rows.push([String(x_tot[i]), String(y_tot[i])]);
    downloadCSV("gear_outline_full_pinion.csv", rows);
  }
  function exportSegmentCSV(){
    if (!state.pinionSeg) return;
    const key = ui.segSelect.value;
    const seg = state.pinionSeg[key];
    if (!seg || seg.length===0) return;

    const rows = [["x_mm","y_mm"]];
    for (const p of seg) rows.push([String(p[0]), String(p[1])]);

    const mapName = {
      rootL:"01_rootCircle_L",
      troL:"02_trochoid_L",
      invL:"03_involute_L",
      add:"04_addendumArc",
      invR:"05_involute_R",
      troR:"06_trochoid_R",
      rootR:"07_rootCircle_R"
    };
    downloadCSV(mapName[key] + "_pinion.csv", rows);
  }

  function exportToothCSV2(){
    if (!state.gearTooth) return;
    const {x_tooth,y_tooth} = state.gearTooth;
    const rows = [["x_mm","y_mm"]];
    for (let i=0;i<x_tooth.length;i++) rows.push([String(x_tooth[i]), String(y_tooth[i])]);
    downloadCSV("tooth_outline_sector_gear.csv", rows);
  }
  function exportGearCSV2(){
    if (!state.gearFull) return;
    const {x_tot,y_tot} = state.gearFull;
    const rows = [["x_mm","y_mm"]];
    for (let i=0;i<x_tot.length;i++) rows.push([String(x_tot[i]), String(y_tot[i])]);
    downloadCSV("gear_outline_full_gear.csv", rows);
  }
  function exportSegmentCSV2(){
    if (!state.gearSeg) return;
    const key = ui.segSelect2.value;
    const seg = state.gearSeg[key];
    if (!seg || seg.length===0) return;

    const rows = [["x_mm","y_mm"]];
    for (const p of seg) rows.push([String(p[0]), String(p[1])]);

    const mapName = {
      rootL:"01_rootCircle_L",
      troL:"02_trochoid_L",
      invL:"03_involute_L",
      add:"04_addendumArc",
      invR:"05_involute_R",
      troR:"06_trochoid_R",
      rootR:"07_rootCircle_R"
    };
    downloadCSV(mapName[key] + "_gear.csv", rows);
  }

  // ----------------------
  // Generation Lab (visual only)
  // ----------------------
  function genReset(){
    state.gen.running = false;
    state.gen.t = 0;
    state.gen.lastTs = 0;
    state.gen.trace = [];
    state.gen.trace2 = [];
    ui.cutPlay.textContent = "Play";
    ui.cutT.value = "0";
    ui.cutTtxt.textContent = "0.000";
    redrawCurrentPage();
  }

  function genSetT(t){
    state.gen.t = clamp(t, 0, 1);
    ui.cutT.value = String(state.gen.t);
    ui.cutTtxt.textContent = fmt(state.gen.t, 3);
    redrawCurrentPage();
  }

  function genEstimateThetaFromContact(gearOrPinion, xC, yC){
    const seg = (gearOrPinion === "gear") ? state.gearSeg : state.pinionSeg;
    if (!seg || !seg.invR || seg.invR.length < 5) return NaN;

    const rC = Math.hypot(xC, yC);
    let best = seg.invR[0], bestErr = Infinity;
    for (const p of seg.invR){
      const rp = Math.hypot(p[0], p[1]);
      const e = Math.abs(rp - rC);
      if (e < bestErr){ bestErr = e; best = p; }
    }
    const angC = Math.atan2(yC, xC);
    const angP = Math.atan2(best[1], best[0]);
    return angC - angP;
  }

  function genMakeStylizedRackToothPolyline(m, alphaRad, Ck, Cf){
    // Stylized rack cutter tooth (visual only):
    // - thickness at pitch line: t = p/2
    // - flanks at pressure angle alpha (standard rack convention)
    const p = Math.PI*m;
    const t = 0.5*p;
    const tanA = Math.tan(alphaRad);

    const yTop = Ck*m;
    const yBot = -Cf*m;

    const xValL = -0.5*p;
    const xValR = +0.5*p;

    const xPitchL = -0.5*t;
    const xPitchR = +0.5*t;

    // (Use converging flanks towards addendum)
    let xTopL = xPitchL + tanA*yTop;
    let xTopR = xPitchR - tanA*yTop;

    const xBotL = xPitchL + tanA*yBot;
    const xBotR = xPitchR - tanA*yBot;

    // Prevent inverted top if extreme inputs
    const minTop = 0.12*m;
    if ((xTopR - xTopL) < minTop){
      const mid = 0.5*(xTopL + xTopR);
      xTopL = mid - 0.5*minTop;
      xTopR = mid + 0.5*minTop;
    }

    return [
      [xValL, yBot],
      [xBotL, yBot],
      [xPitchL, 0],
      [xTopL, yTop],
      [xTopR, yTop],
      [xPitchR, 0],
      [xBotR, yBot],
      [xValR, yBot]
    ];
  }

  function genDrawRackAndGear(cv, which){
    const {ctx, cssW, cssH} = setupHiDPICanvas(cv);

    if (!state.base || !state.oper){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.font = "14px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("‚Äî", 18, 28);
      ctx.restore();
      return;
    }

    const base = state.base;
    const oper = state.oper;
    const isGear = (which === "gear");

    const ra = isGear ? base.ra2 : base.ra1;
    const rf = isGear ? base.rf2 : base.rf1;
    const rb = isGear ? base.rb2 : base.rb1;

    const alphaW = oper.alphaW;

    const idx = Math.round(state.gen.t * (oper.xLOA.length - 1));
    const xC = oper.xLOA[idx];
    const yC = isGear ? (oper.yLOA[idx] - oper.a12) : oper.yLOA[idx];

    let theta = genEstimateThetaFromContact(isGear ? "gear" : "pinion", xC, yC);
    if (!isFinite(theta)){
      const rw = isGear ? oper.rw2 : oper.rw1;
      theta = -xC / Math.max(1e-12, rw);
    }

    const rw_use = isGear ? oper.rw2 : oper.rw1;
    const sRack = -theta * rw_use;

    const pad = 22;
    const rackY0 = rw_use;
    const rackSpanX = 3.2*Math.PI*base.m;
    const rackSpanY = 2.5*base.m*(parseFloat(ui.Ck.value)+parseFloat(ui.Cf.value)+1.0);

    let xmin = -ra - 0.2*ra;
    let xmax =  ra + 0.2*ra;
    let ymin = -ra - 0.2*ra;
    let ymax =  rackY0 + rackSpanY;

    xmin = Math.min(xmin, -rackSpanX);
    xmax = Math.max(xmax,  rackSpanX);
    ymin = Math.min(ymin, rackY0 - rackSpanY);
    ymax = Math.max(ymax, rackY0 + rackSpanY*0.6);

    const w = Math.max(1e-9, xmax-xmin), h = Math.max(1e-9, ymax-ymin);
    const sFit = Math.min((cssW-2*pad)/w, (cssH-2*pad)/h);
    const s = sFit * state.genView.zoom;

    const cx = cssW/2 + state.genView.panX;
    const cy = cssH/2 + state.genView.panY;
    const mx = 0.5*(xmin+xmax);
    const my = 0.5*(ymin+ymax);

    // store current transform (for wheel-zoom anchoring)
    state.genView._rack = {mx, my, sFit, cssW, cssH};

    function X(x){ return cx + (x-mx)*s; }
    function Y(y){ return cy - (y-my)*s; }

    // subtle background
    ctx.save();
    const bg = ctx.createLinearGradient(0, 0, 0, cssH);
    bg.addColorStop(0, "rgba(255,255,255,.03)");
    bg.addColorStop(1, "rgba(255,255,255,.01)");
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,cssW,cssH);
    ctx.restore();

    function circle(r, dash, color){
      ctx.save();
      ctx.strokeStyle = color || "rgba(255,255,255,.12)";
      ctx.lineWidth = 1.2;
      if (dash) ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.arc(X(0), Y(0), Math.max(0, r*s), 0, 2*Math.PI);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,.06)";
    ctx.lineWidth = 1;
    ctx.setLineDash([6,6]);
    ctx.beginPath();
    ctx.moveTo(X(-999), Y(0));
    ctx.lineTo(X( 999), Y(0));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();

    circle(ra, false, "rgba(255,255,255,.10)");
    circle(rw_use, true, "rgba(61,220,151,.16)");
    circle(rb, true, "rgba(122,162,255,.16)");
    circle(rf, false, "rgba(255,255,255,.08)");

    if (ui.cutShowLOA.checked){
      const px = 0, py = rw_use;
      const dx = Math.cos(alphaW), dy = -Math.sin(alphaW);
      const L = 3.0*ra;
      ctx.save();
      ctx.strokeStyle = "rgba(61,220,151,.55)";
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      ctx.moveTo(X(px - L*dx), Y(py - L*dy));
      ctx.lineTo(X(px + L*dx), Y(py + L*dy));
      ctx.stroke();
      ctx.restore();
    }

    const full = isGear ? state.gearFull : state.pinionFull;
    if (full){
      ctx.save();
      ctx.strokeStyle = isGear ? "rgba(255,107,107,.95)" : "rgba(122,162,255,.95)";
      ctx.lineWidth = 2.25;
      ctx.beginPath();
      for (let i=0;i<full.x_tot.length;i++){
        const [xx,yy] = rotateXY(full.x_tot[i], full.y_tot[i], theta);
        const px = X(xx), py = Y(yy);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }
    if (ui.cutShowRack.checked){
      const Ck = parseFloat(ui.Ck.value);
      const Cf = parseFloat(ui.Cf.value);

      const rackTooth = genMakeStylizedRackToothPolyline(base.m, base.alphaRad, Ck, Cf);
      const pitch = Math.PI*base.m;
      const nTooth = 9;

      // Rack "body" (bar) above the teeth (classic textbook look)
      const yTop = Ck*base.m;
      const bodyH = 1.15*base.m;
      const yBodyBot = rackY0 + yTop;
      const yBodyTop = yBodyBot + bodyH;

      ctx.save();
      ctx.fillStyle = "rgba(180,124,255,.07)";
      ctx.strokeStyle = "rgba(180,124,255,.22)";
      ctx.lineWidth = 1.25;
      const xL = X(-999), xR = X(999);
      const yT = Y(yBodyTop), yB = Y(yBodyBot);
      ctx.beginPath();
      ctx.rect(xL, yT, xR-xL, yB-yT);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // Highlight tooth closest to the current contact x-position
      const kSel = Math.round((xC - sRack) / pitch);

      ctx.save();
      for (let k=-Math.floor(nTooth/2); k<=Math.floor(nTooth/2); k++){
        const dxk = k*pitch + sRack;
        const isActive = (k === kSel);

        ctx.strokeStyle = isActive ? "rgba(180,124,255,.96)" : "rgba(180,124,255,.72)";
        ctx.fillStyle   = isActive ? "rgba(180,124,255,.14)" : "rgba(180,124,255,.06)";
        ctx.lineWidth   = isActive ? 2.35 : 2.0;

        ctx.beginPath();
        for (let i=0;i<rackTooth.length;i++){
          const xr = rackTooth[i][0] + dxk;
          const yr = rackTooth[i][1] + rackY0;
          const px = X(xr), py = Y(yr);
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      // Pitch line of rack (reference)
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 1.2;
      ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.moveTo(X(-999), Y(rackY0));
      ctx.lineTo(X( 999), Y(rackY0));
      ctx.stroke();
      ctx.setLineDash([]);

      // Small label
      ctx.fillStyle = "rgba(255,255,255,.75)";
      ctx.font = "900 11px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("Rack cutter (stylized)", 14, 54);

      ctx.restore();
    }

    ctx.save();
    ctx.fillStyle = "rgba(61,220,151,.95)";
    ctx.shadowColor = "rgba(0,0,0,.45)";
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(X(xC), Y(yC), 3.0, 0, 2*Math.PI);
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.font = "900 12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText(isGear ? "Simulation: gear-centered rack-generation" : "Simulation: pinion-centered rack-generation", 14, 18);
    ctx.fillStyle = "rgba(255,255,255,.70)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText(`Œ∏‚âà${fmt(theta,3)} rad,  rack shift‚âà${fmt(sRack,2)} mm`, 14, 36);
    ctx.restore();
  }

  function genDrawTrace(cv, which){
    const {ctx, cssW, cssH} = setupHiDPICanvas(cv);

    if (!state.base || !state.oper){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.55)";
      ctx.font = "14px " + getComputedStyle(document.body).fontFamily;
      ctx.fillText("‚Äî", 18, 28);
      ctx.restore();
      return;
    }

    const base = state.base;
    const oper = state.oper;
    const isGear = (which === "gear");

    const rb = isGear ? base.rb2 : base.rb1;
    const ra = isGear ? base.ra2 : base.ra1;

    const seg = isGear ? state.gearSeg : state.pinionSeg;
    const trace = isGear ? state.gen.trace2 : state.gen.trace;

    const idx = Math.round(state.gen.t * (oper.xLOA.length - 1));
    const xW = oper.xLOA[idx];
    const yW = oper.yLOA[idx];

    const xC = xW;
    const yC = isGear ? (yW - oper.a12) : yW;

    let theta = genEstimateThetaFromContact(isGear ? "gear" : "pinion", xC, yC);
    if (!isFinite(theta)){
      const rw = isGear ? oper.rw2 : oper.rw1;
      theta = -xC / Math.max(1e-12, rw);
    }

    const [xL, yL] = rotateXY(xC, yC, -theta);

    if (ui.cutShowTrace.checked){
      const last = trace.length ? trace[trace.length-1] : null;
      const d = last ? Math.hypot(last[0]-xL, last[1]-yL) : Infinity;
      if (d > 0.08*base.m){
        trace.push([xL, yL]);
        if (trace.length > 2000) trace.shift();
      }
    }

    const pad = 22;
    const xmin = -1.15*ra, xmax = 1.15*ra, ymin = -1.15*ra, ymax = 1.15*ra;

    const w = Math.max(1e-9, xmax-xmin), h = Math.max(1e-9, ymax-ymin);
    const sFit = Math.min((cssW-2*pad)/w, (cssH-2*pad)/h);
    const s = sFit * state.genView.zoom;

    const cx = cssW/2 + state.genView.panX;
    const cy = cssH/2 + state.genView.panY;
    const mx = 0.5*(xmin+xmax);
    const my = 0.5*(ymin+ymax);

    // store current transform (for wheel-zoom anchoring)
    state.genView._trace = {mx, my, sFit, cssW, cssH};

    function X(x){ return cx + (x-mx)*s; }
    function Y(y){ return cy - (y-my)*s; }

    ctx.save();
    const g = ctx.createLinearGradient(0, 0, 0, cssH);
    g.addColorStop(0, "rgba(255,255,255,.03)");
    g.addColorStop(1, "rgba(255,255,255,.01)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,cssW,cssH);
    ctx.restore();

    function circle(r, dash, color){
      ctx.save();
      ctx.strokeStyle = color || "rgba(255,255,255,.12)";
      ctx.lineWidth = 1.2;
      if (dash) ctx.setLineDash([6,6]);
      ctx.beginPath();
      ctx.arc(X(0), Y(0), r*s, 0, 2*Math.PI);
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }
    circle(ra, false, "rgba(255,255,255,.10)");
    circle(rb, true, "rgba(122,162,255,.14)");

    if (ui.cutShowTarget.checked && seg && seg.invR && seg.invR.length > 2){
      ctx.save();
      ctx.strokeStyle = isGear ? "rgba(255,107,107,.55)" : "rgba(122,162,255,.55)";
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      for (let i=0;i<seg.invR.length;i++){
        const p = seg.invR[i];
        const px = X(p[0]), py = Y(p[1]);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }

    if (ui.cutShowTrace.checked && trace.length > 2){
      ctx.save();
      ctx.strokeStyle = "rgba(61,220,151,.82)";
      ctx.lineWidth = 2.2;
      ctx.beginPath();
      for (let i=0;i<trace.length;i++){
        const p = trace[i];
        const px = X(p[0]), py = Y(p[1]);
        if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.stroke();
      ctx.restore();
    }

    ctx.save();
    ctx.fillStyle = "rgba(61,220,151,.95)";
    ctx.shadowColor = "rgba(0,0,0,.45)";
    ctx.shadowBlur = 6;
    ctx.beginPath();
    ctx.arc(X(xL), Y(yL), 3.0, 0, 2*Math.PI);
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(0,0,0,.25)";
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.font = "900 12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText(isGear ? "Simulation: trace in gear-local frame" : "Simulation: trace in pinion-local frame", 14, 18);
    ctx.fillStyle = "rgba(255,255,255,.70)";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText(`trace pts: ${trace.length} | phase=${fmt(state.gen.t,3)}`, 14, 36);
    ctx.restore();
  }

  function drawGenerationLab(){
    const which = ui.cutView.value === "gear" ? "gear" : "pinion";
    genDrawRackAndGear(ui.cvCutRack, which);
    genDrawTrace(ui.cvCutTrace, which);
  }

  function genAnimStep(ts){
    if (!state.gen.running){
      state.gen.lastTs = 0;
      return;
    }
    if (!state.gen.lastTs) state.gen.lastTs = ts;
    const dt = Math.max(0, (ts - state.gen.lastTs) / 1000);
    state.gen.lastTs = ts;

    const speed = state.gen.speed;
    let t = state.gen.t + dt * 0.18 * speed;
    if (t >= 1){
      t = 1;
      state.gen.running = false;
      ui.cutPlay.textContent = "Play";
    }
    state.gen.t = t;
    ui.cutT.value = String(state.gen.t);
    ui.cutTtxt.textContent = fmt(state.gen.t, 3);

    if (state.activePage === "generation"){
      drawGenerationLab();
    }
    if (state.gen.running) requestAnimationFrame(genAnimStep);
  }

  // ----------------------
  // Main compute
  // ----------------------
  function computeAll(){
    showErr(ui.errBox, "");
    showErr(ui.agmaErr, "");
    showErr(ui.isoErr, "");

    state.pinionTooth = null;
    state.pinionFull  = null;
    state.pinionSeg   = null;
    state.gearTooth   = null;
    state.gearFull    = null;
    state.gearSeg     = null;

    try {
      const m = parseFloat(ui.m.value);
      const alphaRad = deg2rad(parseFloat(ui.alpha.value));
      const z1 = parseInt(ui.z1.value, 10);
      const z2 = parseInt(ui.z2.value, 10);

      const x1 = parseFloat(ui.x1.value);
      const x2 = parseFloat(ui.x2.value);
      if (!isFinite(x1) || !isFinite(x2)) throw new Error("Profile shifts x1, x2 must be finite numbers.");

      const Ck = parseFloat(ui.Ck.value);
      const Cf = parseFloat(ui.Cf.value);

      let Cc = parseFloat(ui.Cc.value);
      if (!isFinite(Cc)) Cc = Math.max(0, Cf - Ck);
      if (!(Cc >= 0)) throw new Error("C_c must be ‚â• 0.");

      const rc = parseFloat(ui.rc.value);
      const N = parseInt(ui.N.value, 10);

      const rpm = parseFloat(ui.rpm.value);
      const torque = parseFloat(ui.torque.value);
      const b = parseFloat(ui.b.value);

      if (!(isFinite(rpm) && rpm > 0)) throw new Error("n‚ÇÅ must be > 0.");
      if (!(isFinite(torque) && torque > 0)) throw new Error("T‚ÇÅ must be > 0.");
      if (!(isFinite(b) && b > 0)) throw new Error("b must be > 0.");

      const oper = computeOperatingFromShifts({
        m,z1,z2,alpha0:alphaRad,Ck,Cf,x1,x2,Nlo: Math.max(200, Math.min(1200, N))
      });

      const base = computeInvoluteLOAandProfile({m,z1,z2,alphaRad,Ck,Cf,x1,x2,N});

      const inter = checkOperatingInterferenceOperating(oper);
      const uc1 = checkManufacturingUndercut(z1, alphaRad, Cf, Cc, x1);
      const uc2 = checkManufacturingUndercut(z2, alphaRad, Cf, Cc, x2);

      let tip1 = NaN, tip2 = NaN;

      state.base = base;
      state.oper = oper;
      state.qc = { tip1, tip2, inter, uc1, uc2 };

      let buildErr = null;

      try{
        let xrRack = base.xrLOA.slice();
        let yrRack = base.yrLOA.slice();
        if (yrRack[yrRack.length-1] > yrRack[0]){ xrRack.reverse(); yrRack.reverse(); }

        const cdel = 0.0;
        const phir_new = deg2rad(75);
        const offset = 0.9;
        const rc_target = (isFinite(rc) && rc > 0) ? rc : (0.1*m);

        const to = m*Math.PI;
        const So_nom = to*0.495;
        const So1 = So_nom + 2*x1*m*Math.tan(alphaRad);
        const So2 = So_nom + 2*x2*m*Math.tan(alphaRad);

        const Cf1_eff = Cf - x1;
        const Cf2_eff = Cf - x2;
        if (!(Cf1_eff > 0 && Cf2_eff > 0)) throw new Error("Invalid shifts: (Cf - x) must remain > 0 for fillet/root.");

        const fil1 = rack_fillet_v2(m, z1, xrRack, yrRack, Cf1_eff, cdel, rc_target, phir_new, offset);

        const x_pin = base.xPP.slice();
        const y_pin = base.yPP.map(v => v + base.ro1);

        const rot1 = -0.5*So1/base.ro1;

        const xR1 = [], yR1 = [];
        for (let i=0;i<x_pin.length;i++){
          const [xx,yy] = rotateXY(x_pin[i], y_pin[i], rot1);
          xR1.push(xx); yR1.push(yy);
        }

        const xTr1 = [], yTr1 = [];
        for (let i=0;i<fil1.x_pin_tr.length;i++){
          const [xx,yy] = rotateXY(fil1.x_pin_tr[i], fil1.y_pin_tr[i], rot1);
          xTr1.push(xx); yTr1.push(yy);
        }

        let x_in1 = xR1.slice(), y_in1 = yR1.slice();
        const r_in1 = x_in1.map((vx,i)=> Math.hypot(vx,y_in1[i]));
        if (r_in1[0] < r_in1[r_in1.length-1]){ x_in1.reverse(); y_in1.reverse(); }

        let xtr_in1 = xTr1.slice(), ytr_in1 = yTr1.slice();
        const r_tr1 = xtr_in1.map((vx,i)=> Math.hypot(vx,ytr_in1[i]));
        if (r_tr1[r_tr1.length-1] > r_tr1[0]){ xtr_in1.reverse(); ytr_in1.reverse(); }

        const bridged1 = prepend_connector_if_needed(x_in1, y_in1, xtr_in1, ytr_in1, 25);
        xtr_in1 = bridged1.xtr; ytr_in1 = bridged1.ytr;

        const gg1 = gear_generator(x_in1, y_in1, xtr_in1, ytr_in1, z1);

        const fil2 = rack_fillet_v2(m, z2, xrRack, yrRack, Cf2_eff, cdel, rc_target, phir_new, offset);

        const flank2 = mapRackFlankToGear(xrRack, yrRack, alphaRad, base.ro2);
        const rot2 = -0.5*So2/base.ro2;

        const xR2 = [], yR2 = [];
        for (let i=0;i<flank2.x.length;i++){
          const [xx,yy] = rotateXY(flank2.x[i], flank2.y[i], rot2);
          xR2.push(xx); yR2.push(yy);
        }

        const xTr2 = [], yTr2 = [];
        for (let i=0;i<fil2.x_pin_tr.length;i++){
          const [xx,yy] = rotateXY(fil2.x_pin_tr[i], fil2.y_pin_tr[i], rot2);
          xTr2.push(xx); yTr2.push(yy);
        }

        let x_in2 = xR2.slice(), y_in2 = yR2.slice();
        const r_in2 = x_in2.map((vx,i)=> Math.hypot(vx,y_in2[i]));
        if (r_in2[0] < r_in2[r_in2.length-1]){ x_in2.reverse(); y_in2.reverse(); }

        let xtr_in2 = xTr2.slice(), ytr_in2 = yTr2.slice();
        const r_tr2 = xtr_in2.map((vx,i)=> Math.hypot(vx,ytr_in2[i]));
        if (r_tr2[r_tr2.length-1] > r_tr2[0]){ xtr_in2.reverse(); ytr_in2.reverse(); }

        const bridged2 = prepend_connector_if_needed(x_in2, y_in2, xtr_in2, ytr_in2, 25);
        xtr_in2 = bridged2.xtr; ytr_in2 = bridged2.ytr;

        const gg2 = gear_generator(x_in2, y_in2, xtr_in2, ytr_in2, z2);

        const t1 = tipThicknessSignedFromAddArc(gg1.seg.add);
        const t2 = tipThicknessSignedFromAddArc(gg2.seg.add);

        tip1 = t1.sa;
        tip2 = t2.sa;

        if (!(isFinite(tip1) && isFinite(tip2))) {
          throw new Error("Tip thickness computation failed.");
        }
        if (tip1 <= 0){
          throw new Error(`POINTED pinion tooth: s_a1=${fmt(tip1,6)} mm (ŒîŒ∏=${fmt(t1.dtheta,6)} rad).`);
        }
        if (tip2 <= 0){
          throw new Error(`POINTED gear tooth: s_a2=${fmt(tip2,6)} mm (ŒîŒ∏=${fmt(t2.dtheta,6)} rad).`);
        }

        state.lastProfilePP = { x_pp: base.xPP.slice(), y_pp: base.yPP.slice() };

        const order = ["rootL","troL","invL","add","invR","troR","rootR"];

        const x_tooth1 = [], y_tooth1 = [];
        for (const k of order){
          const P = gg1.seg[k] || [];
          for (const p of P){ x_tooth1.push(p[0]); y_tooth1.push(p[1]); }
        }

        const x_tooth2 = [], y_tooth2 = [];
        for (const k of order){
          const P = gg2.seg[k] || [];
          for (const p of P){ x_tooth2.push(p[0]); y_tooth2.push(p[1]); }
        }

        state.pinionTooth = { x_tooth: x_tooth1, y_tooth: y_tooth1 };
        state.pinionFull  = { x_tot: gg1.x_tot, y_tot: gg1.y_tot };
        state.pinionSeg   = gg1.seg;

        state.gearTooth = { x_tooth: x_tooth2, y_tooth: y_tooth2 };
        state.gearFull  = { x_tot: gg2.x_tot, y_tot: gg2.y_tot };
        state.gearSeg   = gg2.seg;

      } catch(e){
        buildErr = e;
      }

      state.qc.tip1 = tip1;
      state.qc.tip2 = tip2;

      if (ui.agmaAutoJ.checked) autoComputeJBoth();
      if (ui.agmaAutoI.checked) autoComputeI();
      state.agma = computeAGMAAll();

      if (ui.isoAutoY.checked) autoComputeISOY();
      state.iso = computeISOAll();

      genReset();

      updateAllUI();
      redrawCurrentPage();

      if (buildErr){
        showErr(ui.errBox, 'Geometry build warning: <span class="mono">'+String(buildErr.message || buildErr)+'</span>');
      } else {
        showErr(ui.errBox, "");
      }

    } catch(err){
      console.error(err);

      state.base = null;
      state.oper = null;
      state.qc = null;
      state.lastProfilePP = null;

      state.pinionTooth = null;
      state.pinionFull = null;
      state.pinionSeg = null;

      state.gearTooth = null;
      state.gearFull = null;
      state.gearSeg = null;

      state.agma = null;
      state.iso = null;

      genReset();

      updateAllUI();
      redrawCurrentPage();

      showErr(ui.errBox, 'Error: <span class="mono">'+String(err.message || err)+'</span>');
    }
  }

  // ----------------------
  // Navigation + redraw
  // ----------------------
  function setActivePage(key){
    state.activePage = key;
    for (const [k,node] of Object.entries(ui.pages)){
      node.classList.toggle("active", k === key);
    }
    ui.navPages.querySelectorAll(".navbtn").forEach(btn => {
      btn.classList.toggle("active", btn.dataset.page === key);
    });

    if (key === "theory" && window.MathJax && MathJax.typesetPromise){
      MathJax.typesetPromise();
    }

    redrawCurrentPage();
  }

  function redrawCurrentPage(){
    if (state.activePage === "geometry"){
      drawGeometryDual();
      drawMeshView();
    } else if (state.activePage === "strength"){
      drawStrengthDiagrams();
    } else if (state.activePage === "generation"){
      drawGenerationLab();
    } else {
      // export/theory: no canvases needed
    }
  }

  function setZoom(z){
    state.view.zoom = clamp(z, 0.60, 12.00);
    ui.zoom.value = String(state.view.zoom.toFixed(2));
    ui.zoomTxt.textContent = state.view.zoom.toFixed(2) + "√ó";
  }

  function setGenZoom(z){
    state.genView.zoom = clamp(z, 0.60, 12.00);
    if (ui.cutZoom) ui.cutZoom.value = String(state.genView.zoom.toFixed(2));
    if (ui.cutZoomTxt) ui.cutZoomTxt.textContent = state.genView.zoom.toFixed(2) + "√ó";
  }

  // ----------------------
  // AGMA + ISO recalc helpers
  // ----------------------
  function tryRecalcAGMA(){
    showErr(ui.agmaErr, "");
    try{
      if (!state.base){
        state.agma = null;
        updateAllUI();
        return;
      }
      if (ui.agmaAutoJ.checked) autoComputeJBoth();
      if (ui.agmaAutoI.checked) autoComputeI();
      state.agma = computeAGMAAll();
      updateAllUI();
      if (state.activePage === "strength") drawStrengthDiagrams();
    } catch(err){
      state.agma = null;
      updateAllUI();
      showErr(ui.agmaErr, 'AGMA error: <span class="mono">'+String(err.message || err)+'</span>');
    }
  }

  function tryRecalcISO(){
    showErr(ui.isoErr, "");
    try{
      if (!state.base || !state.oper){
        state.iso = null;
        updateAllUI();
        return;
      }
      if (ui.isoAutoY.checked) autoComputeISOY();
      state.iso = computeISOAll();
      updateAllUI();
      if (state.activePage === "strength") drawStrengthDiagrams();
    } catch(err){
      state.iso = null;
      updateAllUI();
      showErr(ui.isoErr, 'ISO error: <span class="mono">'+String(err.message || err)+'</span>');
    }
  }

  // ----------------------
  // Events
  // ----------------------
  ui.zoom.addEventListener("input", () => {
    setZoom(parseFloat(ui.zoom.value));
    if (state.activePage === "geometry") drawMeshView();
  });

  ui.btnResetView.addEventListener("click", () => {
    state.view.panX = 0;
    state.view.panY = 0;
    setZoom(1.0);
    if (state.activePage === "geometry") drawMeshView();
  });

  ui.cvMesh.addEventListener("mousedown", (e) => {
    state.drag.on = true;
    state.drag.x0 = e.clientX;
    state.drag.y0 = e.clientY;
    state.drag.panX0 = state.view.panX;
    state.drag.panY0 = state.view.panY;
  });
  window.addEventListener("mouseup", () => { state.drag.on = false; });
  window.addEventListener("mousemove", (e) => {
    if (!state.drag.on) return;
    const dx = e.clientX - state.drag.x0;
    const dy = e.clientY - state.drag.y0;
    state.view.panX = state.drag.panX0 + dx;
    state.view.panY = state.drag.panY0 + dy;
    if (state.activePage === "geometry") drawMeshView();
  });

  ui.cvMesh.addEventListener("wheel", (e) => {
    e.preventDefault();
    const dir = Math.sign(e.deltaY || 0);
    const factor = (dir > 0) ? (1/1.12) : (1.12);
    setZoom(state.view.zoom * factor);
    if (state.activePage === "geometry") drawMeshView();
  }, {passive:false});

  ui.btnCompute.addEventListener("click", computeAll);
  ui.btnRedraw.addEventListener("click", redrawCurrentPage);

  ui.navPages.addEventListener("click", (e) => {
    const btn = e.target.closest(".navbtn");
    if (!btn) return;
    const key = btn.dataset.page;
    if (key && ui.pages[key]) setActivePage(key);
  });

  [ui.showGear, ui.showLOA].forEach(node => node.addEventListener("change", () => redrawCurrentPage()));

  ui.btnCSV_Profile.addEventListener("click", exportProfileCSV);
  ui.btnCSV_Tooth.addEventListener("click", exportToothCSV);
  ui.btnCSV_Gear.addEventListener("click", exportGearCSV);
  ui.btnCSV_Segment.addEventListener("click", exportSegmentCSV);

  ui.btnCSV_Tooth2.addEventListener("click", exportToothCSV2);
  ui.btnCSV_Gear2.addEventListener("click", exportGearCSV2);
  ui.btnCSV_Segment2.addEventListener("click", exportSegmentCSV2);

  // Generation Lab controls
  ui.cutT.addEventListener("input", () => genSetT(parseFloat(ui.cutT.value)));
  ui.cutSpeed.addEventListener("input", () => {
    state.gen.speed = clamp(parseFloat(ui.cutSpeed.value), 0.25, 3.50);
    ui.cutSpTxt.textContent = fmt(state.gen.speed, 2) + "√ó";
  });
  ui.cutView.addEventListener("change", () => redrawCurrentPage());

  ui.cutZoom.addEventListener("input", () => {
    setGenZoom(parseFloat(ui.cutZoom.value));
    if (state.activePage === "generation") drawGenerationLab();
  });

  ui.cutResetView.addEventListener("click", () => {
    state.genView.panX = 0;
    state.genView.panY = 0;
    setGenZoom(1.0);
    if (state.activePage === "generation") drawGenerationLab();
  });

  function genStartDrag(target, e){
    state.genDrag.on = true;
    state.genDrag.target = target;
    state.genDrag.x0 = e.clientX;
    state.genDrag.y0 = e.clientY;
    state.genDrag.panX0 = state.genView.panX;
    state.genDrag.panY0 = state.genView.panY;
  }

  function genEndDrag(){ state.genDrag.on = false; }

  function genDragMove(e){
    if (!state.genDrag.on) return;
    const dx = e.clientX - state.genDrag.x0;
    const dy = e.clientY - state.genDrag.y0;
    state.genView.panX = state.genDrag.panX0 + dx;
    state.genView.panY = state.genDrag.panY0 + dy;
    if (state.activePage === "generation") drawGenerationLab();
  }

  function genWheelZoom(target, cv, e){
    e.preventDefault();
    const info = (target === "trace") ? state.genView._trace : state.genView._rack;
    const rect = cv.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;

    const cssW = (info && info.cssW) ? info.cssW : (cv.clientWidth || 600);
    const cssH = (info && info.cssH) ? info.cssH : (cv.clientHeight || 300);
    const mx = (info && isFinite(info.mx)) ? info.mx : 0;
    const my = (info && isFinite(info.my)) ? info.my : 0;
    const sFit = (info && isFinite(info.sFit)) ? info.sFit : 1;

    const oldZ = state.genView.zoom;
    const dir = Math.sign(e.deltaY || 0);
    const factor = (dir > 0) ? (1/1.12) : (1.12);
    const newZ = clamp(oldZ * factor, 0.60, 12.00);

    const sOld = sFit * oldZ;
    const sNew = sFit * newZ;

    const cxOld = cssW/2 + state.genView.panX;
    const cyOld = cssH/2 + state.genView.panY;

    const xW = (px - cxOld)/Math.max(1e-12, sOld) + mx;
    const yW = my + (cyOld - py)/Math.max(1e-12, sOld);

    const cxNew = px - (xW - mx)*sNew;
    const cyNew = py + (yW - my)*sNew;

    state.genView.panX = cxNew - cssW/2;
    state.genView.panY = cyNew - cssH/2;

    setGenZoom(newZ);
    if (state.activePage === "generation") drawGenerationLab();
  }

  ui.cvCutRack.addEventListener("mousedown", (e) => genStartDrag("rack", e));
  ui.cvCutTrace.addEventListener("mousedown", (e) => genStartDrag("trace", e));
  window.addEventListener("mouseup", () => genEndDrag());
  window.addEventListener("mousemove", (e) => genDragMove(e));

  ui.cvCutRack.addEventListener("wheel", (e) => genWheelZoom("rack", ui.cvCutRack, e), {passive:false});
  ui.cvCutTrace.addEventListener("wheel", (e) => genWheelZoom("trace", ui.cvCutTrace, e), {passive:false});

  [ui.cutShowLOA, ui.cutShowRack, ui.cutShowTrace, ui.cutShowTarget].forEach(n => n.addEventListener("change", () => redrawCurrentPage()));

  ui.cutPlay.addEventListener("click", () => {
    state.gen.running = !state.gen.running;
    ui.cutPlay.textContent = state.gen.running ? "Pause" : "Play";
    state.gen.lastTs = 0;
    if (state.gen.running){
      requestAnimationFrame(genAnimStep);
    }
  });
  ui.cutReset.addEventListener("click", () => genReset());

  // AGMA
  ui.agmaMat.addEventListener("change", () => { applyMaterialPreset(); tryRecalcAGMA(); });
  ui.agmaAutoJ.addEventListener("change", () => { if (ui.agmaAutoJ.checked) autoComputeJBoth(); tryRecalcAGMA(); });
  ui.agmaAutoI.addEventListener("change", () => { if (ui.agmaAutoI.checked) autoComputeI(); tryRecalcAGMA(); });
  ui.agmaMN.addEventListener("change", () => { if (ui.agmaAutoI.checked) autoComputeI(); tryRecalcAGMA(); });

  ui.btnAGMARecalc.addEventListener("click", () => tryRecalcAGMA());

  ui.btnAGMAReset.addEventListener("click", () => {
    ui.agmaKo.value = "1.00";
    ui.agmaKv.value = "1.10";
    ui.agmaKs.value = "1.00";
    ui.agmaKH.value = "1.30";
    ui.agmaKB.value = "1.00";
    ui.agmaMN.value = "1.00";
    ui.agmaZR.value = "1.00";

    ui.agmaYN.value = "1.00";
    ui.agmaZN.value = "1.00";
    ui.agmaYT.value = "1.00";
    ui.agmaYZ.value = "1.00";
    ui.agmaZW.value = "1.00";
    ui.agmaSF.value = "1.50";
    ui.agmaSH.value = "1.50";

    ui.agmaAutoJ.checked = true;
    ui.agmaAutoI.checked = true;

    ui.agmaMat.value = "steel250";
    applyMaterialPreset();

    tryRecalcAGMA();
  });

  [
    ui.agmaJ1, ui.agmaJ2, ui.agmaI, ui.agmaZR,
    ui.agmaKo, ui.agmaKv, ui.agmaKs, ui.agmaKH, ui.agmaKB, ui.agmaMN,
    ui.agmaSt, ui.agmaSc, ui.agmaE, ui.agmaNu,
    ui.agmaYN, ui.agmaZN, ui.agmaYT, ui.agmaYZ, ui.agmaZW, ui.agmaSF, ui.agmaSH
  ].forEach(inp => inp.addEventListener("input", () => tryRecalcAGMA()));

  // ISO
  ui.isoMat.addEventListener("change", () => { applyISOMaterialPreset(); tryRecalcISO(); });
  ui.isoAutoY.addEventListener("change", () => { if (ui.isoAutoY.checked) autoComputeISOY(); tryRecalcISO(); });
  ui.isoConservativeZeps.addEventListener("change", () => tryRecalcISO());
  ui.btnISORecalc.addEventListener("click", () => tryRecalcISO());

  ui.btnISOReset.addEventListener("click", () => {
    ui.isoKA.value = "1.00";
    ui.isoKv.value = "1.10";
    ui.isoKHb.value = "1.30";
    ui.isoKHa.value = "1.00";
    ui.isoKFb.value = "1.30";
    ui.isoKFa.value = "1.00";

    ui.isoZN.value = "1.00";
    ui.isoZL.value = "1.00";
    ui.isoZR2.value = "1.00";
    ui.isoZV.value = "1.00";
    ui.isoZW2.value = "1.00";
    ui.isoZX.value = "1.00";

    ui.isoYST.value = "1.00";
    ui.isoYNT.value = "1.00";
    ui.isoYdel.value = "1.00";
    ui.isoYR.value = "1.00";
    ui.isoYX.value = "1.00";

    ui.isoSF.value = "1.50";
    ui.isoSH.value = "1.50";

    ui.isoAutoY.checked = true;
    ui.isoConservativeZeps.checked = true;

    ui.isoMat.value = "steel250";
    applyISOMaterialPreset();
    autoComputeISOY();
    tryRecalcISO();
  });

  [
    ui.isoFlim, ui.isoHlim, ui.isoE, ui.isoNu,
    ui.isoYF1, ui.isoYF2, ui.isoYS1, ui.isoYS2,
    ui.isoKA, ui.isoKv, ui.isoKHb, ui.isoKHa, ui.isoKFb, ui.isoKFa,
    ui.isoZN, ui.isoZL, ui.isoZR2, ui.isoZV, ui.isoZW2, ui.isoZX,
    ui.isoYST, ui.isoYNT, ui.isoYdel, ui.isoYR, ui.isoYX,
    ui.isoSF, ui.isoSH
  ].forEach(inp => inp.addEventListener("input", () => tryRecalcISO()));

  window.addEventListener("resize", () => redrawCurrentPage());

  function init(){
    applyMaterialPreset();
    applyISOMaterialPreset();
    setExportsEnabledPinion(false);
    setExportsEnabledGear(false);
    setZoom(1.0);
    setGenZoom(1.0);
    genReset();
    updateAllUI();
    setActivePage("geometry");
    showErr(ui.errBox, "");
    showErr(ui.warnBox, "");
  }
  init();

})();
</script>

</body>
</html>
